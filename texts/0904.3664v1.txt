Introduction to Machine Learning
67577 - Fall, 2008
Amnon Shashua
School of Computer Science and Engineering
The Hebrew University of Jerusalem
Jerusalem, Israel
arXiv:0904.3664v1  [cs.LG]  23 Apr 2009
Contents
1
Bayesian Decision Theory
page 1
1.1
Independence Constraints
5
1.1.1
Example: Coin Toss
7
1.1.2
Example: Gaussian Density Estimation
7
1.2
Incremental Bayes Classiﬁer
9
1.3
Bayes Classiﬁer for 2-class Normal Distributions
10
2
Maximum Likelihood/ Maximum Entropy Duality
12
2.1
ML and Empirical Distribution
12
2.2
Relative Entropy
14
2.3
Maximum Entropy and Duality ML/MaxEnt
15
3
EM Algorithm: ML over Mixture of Distributions
19
3.1
The EM Algorithm: General
21
3.2
EM with i.i.d. Data
24
3.3
Back to the Coins Example
24
3.4
Gaussian Mixture
26
3.5
Application Examples
27
3.5.1
Gaussian Mixture and Clustering
27
3.5.2
Multinomial Mixture and ”bag of words” Application 27
4
Support Vector Machines and Kernel Functions
30
4.1
Large Margin Classiﬁer as a Quadratic Linear Programming 31
4.2
The Support Vector Machine
34
4.3
The Kernel Trick
36
4.3.1
The Homogeneous Polynomial Kernel
37
4.3.2
The non-homogeneous Polynomial Kernel
38
4.3.3
The RBF Kernel
39
4.3.4
Classifying New Instances
39
iii
iv
Contents
5
Spectral Analysis I: PCA, LDA, CCA
41
5.1
PCA: Statistical Perspective
42
5.1.1
Maximizing the Variance of Output Coordinates
43
5.1.2
Decorrelation: Diagonalization of the Covariance
Matrix
46
5.2
PCA: Optimal Reconstruction
47
5.3
The Case n >> m
49
5.4
Kernel PCA
49
5.5
Fisher’s LDA: Basic Idea
50
5.6
Fisher’s LDA: General Derivation
52
5.7
Fisher’s LDA: 2-class
54
5.8
LDA versus SVM
54
5.9
Canonical Correlation Analysis
55
6
Spectral Analysis II: Clustering
58
6.1
K-means Algorithm for Clustering
59
6.1.1
Matrix Formulation of K-means
60
6.2
Min-Cut
62
6.3
Spectral Clustering: Ratio-Cuts and Normalized-Cuts
63
6.3.1
Ratio-Cuts
64
6.3.2
Normalized-Cuts
65
7
The Formal (PAC) Learning Model
69
7.1
The Formal Model
69
7.2
The Rectangle Learning Problem
73
7.3
Learnability of Finite Concept Classes
75
7.3.1
The Realizable Case
76
7.3.2
The Unrealizable Case
77
8
The VC Dimension
80
8.1
The VC Dimension
81
8.2
The Relation between VC dimension and PAC Learning
85
9
The Double-Sampling Theorem
89
9.1
A Polynomial Bound on the Sample Size m for PAC
Learning
89
9.2
Optimality of SVM Revisited
95
10
Appendix
97
Bibliography
105
1
Bayesian Decision Theory
During the next few lectures we will be looking at the inference from training
data problem as a random process modeled by the joint probability distribu-
tion over input (measurements) and output (say class labels) variables. In
general, estimating the underlying distribution is a daunting and unwieldy
task, but there are a number of constraints or ”tricks of the trade” so to
speak that under certain conditions make this task manageable and fairly
eﬀective.
To make things simple, we will assume a discrete world, i.e., that the
values of our random variables take on a ﬁnite number of values. Consider
for example two random variables X taking on k possible values x1, ..., xk
and H taking on two values h1, h2. The values of X could stand for a Body
Mass Index (BMI) measurement weight/height2 of a person and H stands
for the two possibilities h1 standing for the ”person being over-weight” and
h2 as the possibility ”person of normal weight”. Given a BMI measurement
we would like to estimate the probability of the person being over-weight.
The joint probability P(X, H) is a two dimensional array (2-way array)
with 2k entries (cells). Each training example (xi, hj) falls into one of those
cells, therefore P(X = xi, H = hj) = P(xi, hj) holds the ratio between the
number of hits into cell (i, j) and the total number of training examples
(assuming the training data arrive i.i.d.). As a result P
ij P(xi, hj) = 1.
The projections of the array onto its vertical and horizontal axes by sum-
ming over columns or over rows is called marginalization and produces
P(hj) = P
i P(xi, hj) the sum over the j’th row is the probability P(H = hj),
i.e., the probability of a person being over-weight (or not) before we see any
measurement — these are called priors. Likewise, P(xi) = P
j P(xi, hj)
is the probability P(X = xi) which is the probability of receiving such
a BMI measurement to begin with — this is often called evidence. Note
1
2
Bayesian Decision Theory
h1
2
5
4
2
1
h2
0
0
3
3
2
x1
x2
x3
x4
x5
Fig. 1.1. Joint probability P(X, H) where X ranges over 5 discrete values and H
over two values. Each entry contains the number of hits for the cell (xi, hj). The
joint probability P(xi, hj) is the number of hits divided by the total number of hits
(22). See text for more details.
that, by deﬁnition, P
j P(hj) = P
i P(xi) = 1. In Fig. 1.1 we have that
P(h1) = 14/22, P(h2) = 8/22 that is there is a higher prior probability of a
person being over-weight than being of normal weight. Also P(x3) = 7/22
is the highest meaning that we encounter BMI = x3 with the highest prob-
ability.
The conditional probability P(hj | xi) = P(xi, hj)/P(xi) is the ratio be-
tween the number of hits in cell (i, j) and the number of hits in the i’th
column, i.e., the probability that the outcome is H = hj given the measure-
ment X = xi. In Fig. 1.1 we have P(h2 | x3) = 3/7. Note that
X
j
P(hj | xi) =
X
j
P(xi, hj)
P(xi)
=
1
P(xi)
X
j
P(xi, hj) = P(xi)/P(xi) = 1.
Likewise, the conditional probability P(xi | hj) = P(xi, hj)/P(hj) is the
number of hits in cell (i, j) normalized by the number of hits in the j’th row
and represents the probability of receiving BMI = xi given the class label
H = hj (over-weight or not) of the person. In Fig. 1.1 we have P(x3 | h2) =
3/8 which is the probability of receiving BMI = x3 given that the person is
known to be of normal weight. Note that P
i P(xi | hj) = 1.
The Bayes formula arises from:
P(xi | hj)P(hj) = P(xi, hj) = P(hj | xi)P(xi),
from which we get:
P(hj | xi) = P(xi | hj)P(hj)
P(xi)
.
The left hand side P(hj | xi) is called the posterior probability and P(xi | hj)
is called the class conditional likelihood.
The Bayes formula provides a
way to estimate the posterior probability from the prior, evidence and class
likelihood. It is useful in cases where it is natural to compute (or collect
data of) the class likelihood, yet it is not quite simple to compute directly
Bayesian Decision Theory
3
the posterior.
For example, given a measurement ”12” we would like to
estimate the probability that the measurement came from tossing a pair
of dice or from spinning a roulette table. If x = 12 is our measurement,
and h1 stands for ”pair of dice” and h2 for ”roulette” then it is natural
to compute the class conditional: P(”12” | ”pair of dice”) = 1/36 and
P(”12” | ”roulette”) = 1/38.
Computing the posterior directly is much
more diﬃcult. As another example, consider medical diagnosis. Once it is
known that a patient suﬀers from some disease hj, it is natural to evaluate
the probabilities P(xi | hj) of the emerging symptoms xi. As a result, in
many inference problems it is natural to use the class conditionals as the
basic building blocks and use the Bayes formula to invert those to obtain
the posteriors.
The Bayes rule can often lead to unintuitive results — the one in particu-
lar is known as ”base rate fallacy” which shows how an nonuniform prior can
inﬂuence the mapping from likelihoods to posteriors. On an intuitive basis,
people tend to ignore priors and equate likelihoods to posteriors. The follow-
ing example is typical: consider the ”Cancer test kit” problem† which has the
following features: given that the subject has Cancer ”C”, the probability
of the test kit producing a positive decision ”+” is P(+ | C) = 0.98 (which
means that P(−| C) = 0.02) and the probability of the kit producing a neg-
ative decision ”-” given that the subject is healthy ”H” is P(−| H) = 0.97
(which means also that P(+ | H) = 0.03). The prior probability of Cancer
in the population is P(C) = 0.01. These numbers appear at ﬁrst glance
as quite reasonable, i.e, there is a probability of 98% that the test kit will
produce the correct indication given that the subject has Cancer. What
we are actually interested in is the probability that the subject has Cancer
given that the test kit generated a positive decision, i.e., P(C | +). Using
Bayes rule:
P(C | +) = P(+ | C)P(C)
P(+)
=
P(+ | C)P(C)
P(+ | C)P(C) + P(+ | H)P(H) = 0.266
which means that there is a 26.6% chance that the subject has Cancer given
that the test kit produced a positive response — by all means a very poor
performance.
If we draw the posteriors P(h1 |x) and P(h2 | x) using the probability
distribution array in Fig. 1.1 we will see that P(h1 |x) > P(h2 | x) for all
values of X smaller than a value which is in between x3 and x4. Therefore
the decision which will minimize the probability of misclassiﬁcation would
† This example is adopted from Yishai Mansour’s class notes on Machine Learning.
4
Bayesian Decision Theory
be to choose the class with the maximal posterior:
h∗= argmax
j
P(hj | x),
which is known as the Maximal A Posteriori (MAP) decision principle. Since
P(x) is simply a normalization factor, the MAP principle is equivalent to:
h∗= argmax
j
P(x | hj)P(hj).
In the case where information about the prior P(h) is not known or it is
known that the prior is uniform, the we obtain the Maximum Likelihood
(ML) principle:
h∗= argmax
j
P(x | hj).
The MAP principle is a particular case of a more general principle, known
as ”proper Bayes”, where a loss is incorporated into the decision process.
Let l(hi, hj) be the loss incurred by deciding on class hi when in fact hj is
the correct class. For example, the ”0/1” loss function is:
l(hi, hj) =
 1
i ̸= j
0
i = j

The least-squares loss function is: l(hi, hj) = ∥hi −hj∥2 typically used when
the outcomes are vectors in some high dimensional space rather than class
labels. We deﬁne the expected risk:
R(hi | x) =
X
j
l(hi, hj)P(hj | x).
The proper Bayes decision policy is to minimize the expected risk:
h∗= argmin
j
R(hj | x).
The MAP policy arises in the case l(hi, hj) is the 0/1 loss function:
R(hi | x) =
X
j̸=i
P(hj | x) = 1 −P(hi | x),
Thus,
argmin
j
R(hj | x) = argmax
j
P(hj | x).
1.1 Independence Constraints
5
1.1 Independence Constraints
At this point we may pause and ask what have we obtained?
well, not
much. Clearly, the inference problem is captured by the joint probability
distribution and we do not need all these formulas to see this.
How do
we obtain the necessary data to ﬁll in the probability distribution array to
begin with? Clearly without additional simplifying constraints the task is
not practical as the size of these kind of arrays are exponential in the number
of variables. There are three families of simplifying constraints used in the
literature:
• statistical independence constraints,
• parametric form of the class likelihood P(xi | hj) where the inference
becomes a density estimation problem,
• structural assumptions — latent (hidden) variables, graphical models.
Today we will focus on the ﬁrst of these simplifying constraints — statistical
independence properties.
Consider two random variables X and Y . The variables are statistically
independent X⊥Y if P(X | Y ) = P(X) meaning that information about
the value of Y does not add anything about X. The independence condition
is equivalent to the constraint: P(X, Y ) = P(X)P(Y ). This can be easily
proven: if X⊥Y then P(X, Y ) = P(X | Y )P(Y ) = P(X)P(Y ). On the
other hand, if P(X, Y ) = P(X)P(Y ) then
P(X | Y ) = P(X, Y )
P(Y )
= P(X)P(Y )
P(Y )
= P(X).
Let the values of X range over x1, ..., xk and the values of Y range over
y1, ..., yl. The associated k × l 2-way array, P(X = xi, Y = yj) is repre-
sented by the outer product P(xi, yj) = P(xi)P(yj) of two vectors P(X) =
(P(x1), ..., P(xk)) and P(Y ) = (P(y1), ..., P(yl)). In other words, the 2-way
array viewed as a matrix is of rank 1 and is determined by k + l (minus 2
because the sum of each vector is 1) parameters rather than kl (minus 1)
parameters.
Likewise, if X1⊥X2⊥....⊥Xn are n statistically independent random vari-
ables where Xi ranges over ki discrete and distinct values, then the n-way
array P(X1, ..., Xn) = P(X1) · ... · P(Xn) is an outer-product of n vectors
and is therefore determined by k1 + ... + kn (minus n) parameters instead
of k1k2...kn (minus 1) parameters†. Viewed as a tensor, the joint probabil-
† I am a bit over simplifying things because we are ignoring here the fact that the entries of
the array should be non-negative. This means that there are additional non-linear constraints
which eﬀectively reduce the number of parameters — but nevertheless it stays exponential.
6
Bayesian Decision Theory
ity is a rank 1 tensor. The main point is that the statistical independence
assumption reduced the representation of the multivariate joint distribution
from exponential to linear size.
Since our variables are typically divided to measurement variables and
an output/class variable H (or in general H1, ..., Hl), it is useful to intro-
duce another, weaker form, of independence known as conditional indepen-
dence. Variables X, Y are conditionally independent given H, denoted by
X⊥Y | H, iﬀP(X | Y, H) = P(X | H) meaning that given H, the value of Y
does not add any information about X. This is equivalent to the condition
P(X, Y | H) = P(X | H)P(Y | H). The proof goes as follows:
• If P(X | Y, H) = P(X | H), then
P(X, Y | H)
=
P(X, Y, H)
P(H)
= P(X | Y, H)P(Y, H)
P(H)
=
P(X | Y, H)P(Y | H)P(H)
P(H)
= P(X | H)P(Y | H)
• If P(X, Y | H) = P(X | H)P(Y | H), then
P(X | Y, H) = P(X, Y, H)
P(Y, H)
= P(X, Y | H)
P(Y | H)
= P(X | H).
Consider as an example, Joe and Mo live on opposite sides of the city.
Joe goes to work by train and Mo by car. Let X be the event ”Joe is late
to work” and Y be the event ”Mo is late for work”. Clearly X and Y are
not independent because there could be other factors. For example, a train
strike will cause Joe to be late, but because of the strike there would be
extra traﬃc (people using their car instead of the train) thus causing Mo to
be pate as well. Therefore, a third variable H standing for the event ”train
strike” would decouple X and Y .
From a computational standpoint, the conditional independence assump-
tion has a similar eﬀect to the unconditional independence. Let X range
over k distinct value, Y range over r distinct values and H range over s
distinct values. Then P(X, Y, H) is a 3-way array of size k × r × s. Given
that X⊥Y | H means that P(X, Y | H = hi), a 2-way ”slice” of the 3-way
array along the H axis is represented by the outer-product of two vectors
P(X | H = hi)P(Y | H = hi). As a result the 3-way array is represented by
s(k +r −2) parameters instead of skr −1. Likewise, if X1⊥....⊥Xn | H then
the n-way array P(X1, ..., Xn | H = hi) (which is a slice along the H axis of
the (n + 1)-array P(X1, ..., Xn, H)) is represented by an outer-product of n
vectors, i.e., by k1 + .. + kn −n parameters.
1.1 Independence Constraints
7
1.1.1 Example: Coin Toss
We will use the ML principle to estimate the bias of a coin. Let X be a
random variable taking the value {0, 1} and H would be our hypothesis
taking a real value in [0, 1] standing for the coin’s bias. If the coin’s bias is
q then P(X = 0 | H = q) = q and P(X = 1 | H = q) = 1 −q. We receive m
i.i.d. examples x1, ..., xm where xi ∈{0, 1}. We wish to determine the value
of q. Given that x1⊥...⊥xm | H, the ML problem we must solve is:
q∗= argmax
q
P(x1, ..., xm | H = q) =
m
Y
i=1
P(xi | q) = argmax
q
X
i
log P(xi | q).
Let 0 ≤λ ≤m stand for the number of ’0’ instances, i.e., λ = |{xi = 0 | i =
1, ..., m}|. Therefore our ML problem becomes:
q∗= argmax
q
{λ log q + (n −λ) log(1 −q)}
Taking the partial derivative with respect to q and setting it to zero:
∂
∂q[λ log q + (n −λ) log(1 −q)] = λ
q∗−n −λ
1 −q∗= 0,
produces the result:
q∗= λ
n.
1.1.2 Example: Gaussian Density Estimation
So far we considered constraints induced by conditional independent state-
ments among the random variables as a means to reduce the space and time
complexity of the multivariate distribution array. Another approach would
be to assume some form of parametric form governing the entries of the array
— the most popular assumption is Gaussian distribution P(X1, ..., Xn) ∼
N(µ, E) with mean vector µ and covariance matrix E. The parameters of
the density function are denoted by θ = (µ, E) and for every vector x ∈Rn
we have:
P(x | θ) =
1
(2π)n/2|E|1/2 exp−1
2 (x−µ)⊤E−1(x−µ) .
Assume we are given an i.i.d sample of k points S = {x1, ..., xk}, xi ∈Rn,
and we would like to ﬁnd the Bayes optimal θ:
θ∗= argmax
θ
P(S | θ),
8
Bayesian Decision Theory
by maximizing the likelihood (here we are assuming that the the priors P(θ)
are equal, thus the maximum likelihood and the MAP would produce the
same result). Because the sample was drawn i.i.d. we can assume that:
P(S | θ) =
k
Y
i=1
P(xi | θ).
Let L(θ) = log P(S | θ) = P
i log P(xi | θ) and since Log is monotonously
increasing we have that θ∗= argmax
θ
L(θ). The parameter estimation would
be recovered by taking derivatives with respect to θ, i.e., ∇θL = 0. We have:
L(θ) = −1
2 log |E| −
k
X
i=1
n
2 log(2π) −
X
i
1
2(xi −µ)⊤E−1(xi −µ).
(1.1)
We will start with a simple scenario where E = σ2I, i.e., all the covariances
are zero and all the variances are equal to σ2.
Thus, E−1 = σ−2I and
|E| = σ2n. After substitution (and removal of items which do not depend
on θ) we have:
L(θ) = −nk log σ −1
2
X
i
∥xi −µ∥2
σ2
.
The partial derivative with respect to µ:
∂L
∂µ = σ−2 X
i
(µ −xi) = 0
from which we obtain:
µ = 1
k
k
X
i=1
xi.
The partial derivative with respect to σ is:
∂L
∂σ = nk
σ −σ−3 X
i
∥xi −µ∥2 = 0,
from which we obtain:
σ2 = 1
kn
k
X
i=1
∥xi −µ∥2.
Note that the reason for dividing by n is due to the fact that σ2
1 = ... =
σ2
n = σ2, so that:
1
k
k
X
i=1
∥xi −µ∥2 =
n
X
j=1
σ2
j = nσ2.
1.2 Incremental Bayes Classiﬁer
9
In the general case, E is a full rank symmetric matrix, then the derivative
of eqn. (1.1) with respect to µ is:
∂L
∂µ = E−1 X
i
(µ −xi) = 0,
and since E−1 is full rank we obtain µ = (1/k) P
i xi. For the derivative
with respect to E we note two auxiliary items:
∂|E|
∂E = |E|E−1,
∂
∂E trace(AE−1) = −(E−1AE−1)⊤.
Using the fact that x⊤y = trace(xy⊤) we can transform z⊤E−1z to trace(zz⊤E−1)
for any vector z. Given that E−1 is symmetric, then:
∂
∂E trace(zz⊤E−1) = −E−1zz⊤E−1.
Substituting z = x −µ we obtain:
∂L
∂E = −kE−1 + E−1
 X
i
(xi −µ)(xi −µ)⊤
!
E−1 = 0,
from which we obtain:
E = 1
k
k
X
i=1
(xi −µ)(xi −µ)⊤.
1.2 Incremental Bayes Classiﬁer
Consider another application of conditional dependence which is the Bayes
incremental rule. Suppose we have processed n examples X(n) = {X1, ..., Xn}
and computed somehow P(H | X(n)). We are given a new measurement X
and wish to compute (update) the posterior P(H | X(n), X). We will use
the chain rule†:
P(X | Y, Z) = P(X, Y, Z)
P(Y, Z
) = P(Z | X, Y )P(X | Y )P(Y )
P(Z | Y )P(Y )
= P(Z | X, Y )P(X | Y )
P(Z | Y )
to obtain:
P(H | X(n), X) = P(X | X(n), H)P(H | X(n))
P(X | X(n))
from conditional independence, P(X | X(n), H) = P(X | H). The term
P(X | X(n)) can expanded as follows:
† this is based on the rule P(X1, ..., Xn)
=
P(X1 | X2, ..., Xn)P(X2 | X3, ..., Xn) · · ·
P(Xn−1 | Xn)P(Xn)
10
Bayesian Decision Theory
P(X | X(n))
=
X
i
P(X, X(n) | H = hi)P(H = hi)
P(X(n))
=
X
i
P(X | H = hi)P(X(n) | H = hi)P(H = hi)
P(X(n))
=
X
i
P(X | H = hi)P(H = hi | X(n))
After substitution we obtain:
P(H = hi | X(n), X) =
P(X | H = hi)P(H = hi | X(n))
P
j P(X | H = hj)P(H = hj | X(n)).
The old posterior P(H | X(n)) is now the prior for the updated formula.
Consider the following example†: We have a coin which could be either fair
or biased towards Head at a probability of 0.6. Let H = h1 be the event
that the coin is fair, and H = h2 that the coin is biased. We start with prior
probabilities P(h1) = 0.75 and P(h2) = 0.25 (we have a higher initial belief
that the coin is fair). Suppose our ﬁrst coin toss is a Head, i.e., X1 = ”0”.
Then,
P(h1 | x1) = P(x1 | h1)P(h1)
P(x1)
=
0.5 ∗0.75
0.5 ∗0.75 + 0.6 ∗0.25 = 0.714
and P(h2 | x1) = 0.286. Our posterior belief that the coin is fair has gone
down after a Head toss. Assume we have another measurement X2 = ”0”,
then:
P(h1 | x1, x2) = P(x2 | h1)P(h1 | x1)
normalization
=
0.5 ∗0.714
0.5 ∗0.714 + 0.6 ∗0.286 = 0.675,
and P(h2 | x1, x2) = 0.325, thus our belief that the coin is fair continues to
go down after Head tosses.
1.3 Bayes Classiﬁer for 2-class Normal Distributions
For the last topic in this lecture consider the 2-class inference problem. We
will encountered this problem in this course in the context of SVM and
LDA. In the Bayes framework, if H = {h1, h2} denotes the ”class member”
variable with two possible outcomes, then the MAP decision policy calls for
† adopted from Ron Rivest’s 1994 class notes.
1.3 Bayes Classiﬁer for 2-class Normal Distributions
11
making the decision based on data x:
h∗= argmax
h1,h2
{P(h1 | x), P(h2 | x)} ,
or in other words the class h1 would be chosen if P(h1 | x) > P(h2 | x).
The decision surface (as a function of x) is therefore described by:
P(h1 | x) −P(h2 | x) = 0.
The questions we ask here is what would the Bayes optimal decision sur-
face be like if we assume that the two classes are normally distributed with
diﬀerent means and the same covariance matrix? What we will see is that
under the condition of equal priors P(h1) = P(h2) the decision surface is
a hyperplane — and not only that, it is the same hyperplane produced by
LDA.
Claim 1 If P(h1) = P(h2) and P(x | h1) ∼N(µ1, E) and P(x | h1) ∼
N(µ2, E), the the Bayes optimal decision surface is a hyperplane w⊤(x −
µ) = 0 where µ = (µ1 + µ2)/2 and w = E−1(µ1 −µ2). In other words, the
decision surface is described by:
x⊤E−1(µ1 −µ2) −1
2(µ1 + µ2)E−1(µ1 −µ2) = 0.
(1.2)
Proof:
The decision surface is described by P(h1 | x) −P(h2 | x) = 0
which is equivalent to the statement that the ratio of the posteriors is 1, or
equivalently that the log of the ratio is zero, and using Bayes formula we
obtain:
0 = log P(x | h1)P(h1)
P(x | h2)P(h2) = log P(x | h1)
P(x | h2).
In other words, the decision surface is described by
log P(x | h1)−log P(x | h2) = −1
2(x−µ1)⊤E−1(x−µ1)+1
2(x−µ2)⊤E−1(x−µ2) = 0.
After expanding the two terms we obtain eqn. (1.2).
2
Maximum Likelihood/ Maximum Entropy Duality
In the previous lecture we deﬁned the principle of Maximum Likelihood
(ML): suppose we have random variables X1, ..., Xn form a random sample
from a discrete distribution whose joint probability distribution is P(x | φ)
where x = (x1, ..., xn) is a vector in the sample and φ is a parameter from
some parameter space (which could be a discrete set of values — say class
membership). When P(x | φ) is considered as a function of φ it is called the
likelihood function. The ML principle is to select the value of φ that maxi-
mizes the likelihood function over the observations (training set) x1, ..., xm.
If the observations are sampled i.i.d. (a common, not always valid, assump-
tion), then the ML principle is to maximize:
φ∗= argmax
φ
m
Y
i=1
P(xi | φ) = argmax log
m
Y
i=1
P(xi | φ) = argmax
m
X
i=1
log P(xi | φ)
which due to the product nature of the problem it becomes more convenient
to maximize the log likelihood.
We will take a closer look today at the
ML principle by introducing a key element known as the relative entropy
measure between distributions.
2.1 ML and Empirical Distribution
The ML principle states that the empirical distribution of an i.i.d. sequence
of examples is the closest possible (in terms of relative entropy which would
be deﬁned later) to the true distribution.
To make this statement clear
let X be a set of symbols {a1, ..., an} and let P(a | θ) be the probability
(belonging to a parametric family with parameter θ) of drawing a symbol
a ∈X. Let x1, ..., xm be a sequence of symbols drawn i.i.d. according to P.
The occurrence frequency f(a) measures the number of draws of the symbol
12
2.1 ML and Empirical Distribution
13
a:
f(a) = |{i : xi = a}|,
and let the empirical distribution be deﬁned by
ˆP(a) =
1
P
α∈X f(α)f(a) =
1
∥f∥1
f(a) = (1/m)f(a).
The joint probability P(x1, ..., xm | φ) is equal to the product Q
i P(xi | φ)
which according to the deﬁnitions above is equal to:
P(x1, ..., xm | φ) =
m
Y
i=1
p(xi | θ) =
Y
a∈X
P(a | φ)f(a).
The ML principle is therefore equivalent to the optimization problem:
max
P∈Q
Y
a∈X
P(a | φ)f(a)
(2.1)
where Q = {q ∈Rn : q ≥0, P
i qi = 1} denote the set of n-dimensional
probability vectors (”probability simplex”). Let pi stand for P(ai | φ) and
fi stand for f(ai). Since argmaxxz(x) = argmaxx ln z(x) and given that
ln Q
i pfi
i = P
i fi ln pi the solution to this problem can be found by setting
the partial derivative of the Lagrangian to zero:
L(p, λ, µ) =
n
X
i=1
fi ln pi −λ(
X
i
pi −1) −
X
i
µipi,
where λ is the Lagrange multiplier associated with the equality constraint
P
i pi −1 = 0 and µi ≥0 are the Lagrange multipliers associated with the
inequality constraints pi ≥0. We also have the complementary slackness
condition that sets µi = 0 if pi > 0.
After setting the partial derivative with respect to pi to zero we get:
pi =
1
λ + µi
fi.
Assume for now that fi > 0 for i = 1, ..., n. Then from complementary
slackness we must have µi = 0 (because pi > 0).
We are left therefore
with the result pi = (1/λ)fi. Following the constraint P
i p1 = 1 we obtain
λ = P
i fi. As a result we obtain: P(a | φ) = ˆP(a). In case fi = 0 we could
use the convention 0 ln 0 = 0 and from continuity arrive to pi = 0.
We have arrived to the following theorem:
Theorem 1 The empirical distribution estimate ˆP is the unique Maximum
14
Maximum Likelihood/ Maximum Entropy Duality
Likelihood estimate of the probability model Q on the occurrence frequency
f().
This seems like an obvious result but it actually runs deep because the result
holds for a very particular (and non-intuitive at ﬁrst glance) distance mea-
sure between non-negative vectors. Let dist(f, p) be some distance measure
between the two vectors. The result above states that:
ˆP = argmin
p
dist(f, p) s.t. p ≥0,
X
i
pi = 1,
(2.2)
for some (family?)
of distance measures dist().
It turns out that there
is only one† such distance measure, known as the relative-entropy, which
satisﬁes the ML result stated above.
2.2 Relative Entropy
The relative-entropy (RE) measure D(x||y) between two non-negative vec-
tors x, y ∈Rn is deﬁned as:
D(x||y) =
n
X
i=1
xi ln xi
yi
−
X
i
xi +
X
i
yi.
In the deﬁnition we use the convention that 0 ln 0
0 = 0 and based on con-
tinuity that 0 ln 0
y = 0 and x ln x
0 = ∞.
When x, y are also probability
vectors, i.e., belong to Q, then D(x||y) = P
i xi ln xi
yi is also known as the
Kullback-Leibler divergence. The RE measure is not a distance metric as
it is not symmetric, D(x||y) ̸= D(y||x), and does not satisfy the triangle
inequality. Nevertheless, it has several interesting properties which make it
a fundamental measure in statistical inference.
The relative entropy is always non-negative and is zero if and only if
x = y. This comes about from the log-sum inequality:
X
i
xi ln xi
yi
≥(
X
i
xi) ln
P
i xi
P
i yi
Thus,
D(x||y) ≥(
X
i
xi) ln
P
i xi
P
i yi
−
X
i
xi +
X
i
yi = ¯x ln ¯x
¯y −¯x + ¯y
† not exactly — the picture is a bit more complex.
Csiszar’s 1972 measures:
dist(p, f) =
P
i fiφ(pi/fi) will satisfy eqn. 2.2 provided that φ′−1 is an exponential. However, dist(f, p)
(parameters positions are switched) will not do it, whereas the relative entropy will satisfy
eqn. 2.2 regardless of the order of the parameters p, f.
2.3 Maximum Entropy and Duality ML/MaxEnt
15
But a ln(a/b) ≥a −b for a, b ≥0 iﬀln(a/b) ≥1 −(b/a) which follows from
the inequality ln(x + 1) > x/(x + 1) (which holds for x > −1 and x ̸= 0).
We can state the following theorem:
Theorem 2 Let f ≥0 be the occurrence frequency on a training sample.
ˆP ∈Q is a ML estimate iﬀ
ˆP = argmin
p
D(f||p) s.t. p ≥0,
X
i
pi = 1.
Proof:
D(f||p) = −
X
i
fi ln pi +
X
i
fi ln fi −
X
i
fi + 1,
and
argmin
p
D(f||p) = argmax
p
X
i
fi ln pi = argmax
p
ln
Y
i
pfi
i .
There are two (related) interesting points to make here. First, from the
proof of Thm. 1 we observe that the non-negativity constraint p ≥0 need
not be enforced - as long as f ≥0 (which holds by deﬁnition) the closest p
to f under the constraint P
i pi = 1 must come out non-negative. Second,
the fact that the closest point p to f comes out as a scaling of f (which is by
deﬁnition the empirical distribution ˆP) arises because of the relative-entropy
measure.
For example, if we had used a least-squares distance measure
∥f −p∥2 the result would not be a scaling of f.
In other words, we are
looking for a projection of the vector f onto the probability simplex, i.e.,
the intersection of the hyperplane x⊤1 = 1 and the non-negative orthant
x ≥0. Under relative-entropy the projection is simply a scaling of f (and
this is why we do not need to enforce non-negativity). Under least-sqaures,
a projection onto the hyper-plane x⊤1 = 1 could take us out of the non-
negative orthant (see Fig. 2.1 for illustration). So, relative-entropy is special
in that regard — it not only provides the ML estimate, but also simpliﬁes
the optimization process† (something which would be more noticeable when
we handle a latent class model next lecture).
2.3 Maximum Entropy and Duality ML/MaxEnt
The relative-entropy measure is not symmetric thus we expect diﬀerent out-
comes of the optimization minx D(x||y) compared to miny D(x||y). The lat-
† The fact that non-negativity ”comes for free” does not apply for all class (distribution) models.
This point would be reﬁned in the next lecture.
16
Maximum Likelihood/ Maximum Entropy Duality
f
p
^
p
2
Fig. 2.1. Projection of a non-neagtaive vector f onto the hyperplane P
i xi −1 = 0.
Under relative-entropy the projection ˆP is a scaling of f (and thus lives in the
probability simplex).
Under least-squares the projection p2 lives outside of the
probability simplex, i.e., could have negative coordinates.
ter of the two, i.e., minP∈Q D(P0||P), where P0 is some empirical evidence
and Q is some model, provides the ML estimation. For example, in the
next lecture we will consider Q the set of low-rank joint distributions (called
latent class model) and see how the ML (via relative-entropy minimization)
solution can be found.
Let H(p) = −P
i pi ln pi denote the entropy function. With regard to
minx D(x||y) we can state the following observation:
Claim 2
argmin
p∈Q
D(p|| 1
n1) = argmax
p∈Q
H(p).
Proof:
D(p|| 1
n1) =
X
i
pi ln pi + (
X
i
pi) ln(n) = ln(n) −H(p),
which follows from the condition P
i pi = 1.
In other words, the closest distribution to uniform is achieved by maxi-
mizing the entropy. To make this interesting we need to add constraints.
Consider a linear constraint on p such as P
i αipi = β. To be concrete, con-
2.3 Maximum Entropy and Duality ML/MaxEnt
17
sider a die with six faces thrown many times and we wish to estimate the
probabilities p1, ..., p6 given only the average P
i ipi. Say, the average is 3.5
which is what one would expect from an unbiased die. The Laplace’s prin-
ciple of insuﬃcient reasoning calls for assuming uniformity unless there is
additional information (a controversial assumption in some cases). In other
words, if we have no information except that each pi ≥0 and that P
i pi = 1
we should choose the uniform distribution since we have no reason to choose
any other distribution. Thus, employing Laplace’s principle we would say
that if the average is 3.5 then the most ”likely” distribution is the uniform.
What if β = 4.2? This kind of problem can be stated as an optimization
problem:
max
p H(p) s.t.,
X
i
pi = 1,
X
i
αipi = β,
where αi = i and β = 4.2. We have now two constraints and with the aid
of Lagrange multipliers we can arrive to the result:
pi = exp−(1−λ) expµαi .
Note that because of the exponential pi ≥0 and again ”non-negativity
comes for free”†. Following the constraint P
i pi = 1 we get exp−(1−λ) =
1/ P
i expµαi from which obtain:
pi = 1
Z expµαi,
where Z (a function of µ) is a normalization factor and µ needs to be set by
using β (see later). There is nothing special about the uniform distribution,
thus we could be seeking a probability vector p as close as possible to some
prior probability p0 under the constraints above:
min
p D(p||p0) s.t.,
X
i
pi = 1,
X
i
αipi = β,
with the result:
pi = 1
Z p0i expµαi .
We could also consider adding more linear constraints on p of the form:
P
i fijpi = bj, j = 1, ..., k. The result would be:
pi = 1
Z p0i exp
Pk
j=1 µjfij .
Probability distributions of this form are called Gibbs Distributions.
In
†
Any measure of the class dist(p, p0) = P
i p0iφ(pi/p0i) minimized under linear constraints
will satisfy the result of pi ≥0 provided that φ′−1 is an exponential.
18
Maximum Likelihood/ Maximum Entropy Duality
practical applications the linear constraints on p could arise from average
information about the system such as temperature of a ﬂuid (where pi are
the probabilities of the particles moving at various velocities), rainfall data
or general environmental data (where pi represent the probability of ﬁnding
animal colonies at discrete locations in a 3D map).
A constraint of the
form P
i fijpi = bj states that the expectation Ep[fj] should be equal to
the empirical distribution β = E ˆP [fj] where ˆP is either uniform or given as
input. Let
P = {p ∈Rn : p ≥0,
X
i
pi = 1, Ep[fj] = Eˆp[fj], j = 1, ..., k},
and
Q = {q ∈Rn ; q is a Gibbs distribution}
We could therefore consider looking for the ML solution for the parameters
µ1, ..., µk of the Gibbs distribution:
min
q∈Q D(ˆp||q),
where if ˆp is uniform then min D(ˆp||q) can be replaced by max P
i ln qi
(because D((1/n)1||x) = −ln(n) −P
i ln xi).
As it turns out, the MaxEnt and ML are duals of each other and the
intersection of the two sets P ∩Q contains only a single point which solves
both problems.
Theorem 3 The following are equivalent:
• MaxEnt: q∗= argminp∈PD(p||p0)
• ML: q∗= argminq∈QD(ˆp||q)
• q∗∈P ∩Q
In practice, the duality theorem is used to recover the parameters of the
Gibbs distribution using the ML route (second line in the theorem above)
— the algorithm for doing so is known as the iterative scaling algorithm
(which we will not get into).
3
EM Algorithm: ML over Mixture of Distributions
In Lecture 2 we saw that the Maximum Likelihood (ML) principle over i.i.d.
data is achieved by minimizing the relative entropy between a model Q and
the occurrence-frequency of the training data. Speciﬁcally, let x1, .., xm be
i.i.d. where each xi ∈X d is a d-tupple of symbols taken from an alphabet X
having n diﬀerent letters {a1, ..., an}. Let ˆP be the empirical joint distribu-
tion, i.e., an array with d dimensions where each axis has n entries, i.e., each
entry ˆPi1,...,id, where ij = 1, ..., n, represents the (normalized) co-occurrence
of the d-tupe ai1, ..., aid in the training set x1, ..., xm. We wish to ﬁnd a
joint distribution P ∗(also a d-array) which belongs to some model family
of distributions Q closest as possible to ˆP in relative-entropy:
P ∗= argmin
P∈Q
D( ˆP||P).
In this lecture we will focus on a model of distributions Q which represents
mixtures of simple distributions H— known as latent class models. A latent
class model arises when the joint probability P(X1, ..., Xd) we observe (i.e.,
from which ˆP is generated by observing samples x1, ..., xm) is in fact a
marginal of P(X1, ..., Xd, Y ) where Y is a ”hidden” (or ”latent”) random
variable which has k diﬀerent discrete values α1, .., αk. Then,
P(X1, ..., Xd) =
k
X
j=1
P(X1, ..., Xd | Y = αj)P(Y = αj).
The idea is that given the value of the hidden variable H the problem of
recovering the model P(X1, ..., Xd | Y = αj), which belongs to some family
of joint distributions H, is a relatively simple problem. To make this idea
clearer we consider the following example: Assume we have two coins. The
ﬁrst coin has a probability of heads (”0”) equal to p and the second coin
has a probability of heads equal to q. At each trial we choose to toss coin 1
19
20
EM Algorithm: ML over Mixture of Distributions
with probability λ and coin 2 with probability 1 −λ. Once a coin has been
chosen it is tossed 3 times, producing an observation x ∈{0, 1}3. We are
given a set of such observations D = {x1, ..., xm} where each observation xi
is a triplet of coin tosses (the same coin). Given D, we can construct the
empirical distribution ˆP which is a 2 × 2 × 2 array deﬁned as:
ˆPi1,i2,i3 = 1
m|{xi = {i1, i2, i3}, i = 1, ..., m}|.
Let yi ∈{1, 2} be a random variable associated with the observation xi such
that yi = 1 if xi was generated by coin 1 and yi = 2 if xi was generated
by coin 2.
If we knew the values of yi then our task would be simply
to estimate two separate Bernoulli distributions by separating the triplets
generated from coin 1 from those generated by coin 2. Since yi is not known,
we have the marginal:
P(x = (x1, x2, x3))
=
P(x = (x1, x2, x3) | y = 1)P(y = 1)
+
P(x = (x1, x2, x3) | y = 2)P(y = 2)
=
λpni(1 −p)(3−ni) + (1 −λ)qni(1 −q)(3−ni),(3.1)
where (x1, x2, x3) ∈{0, 1}3 is a triplet coin toss and 0 ≤ni ≤3 is the
number of heads (”0”) in the triplet of tosses. In other words, the likelihood
P(x) of triplet of tosses x = (x1, x2, x3) is a linear combination (”mixture”)
of two Bernoulli distributions. Let H stand for Bernoulli distributions:
H = {u⊗d : u ≥0,
n
X
i=1
ui = 1}
where u⊗d stands for the outer-product of u ∈Rn with itself d times, i.e.,
an n- way array indexed by i1, ..., id, where ij ∈{1, ..., n}, and whose value
there is equal to ui1 · · · uid. The model family Q is a mixture of Bernoulli
distributions:
Q = {
k
X
j=1
λjPj : λ ≥0,
X
j
λj = 1, Pj ∈H},
where speciﬁcally for our coin-toss example becomes:
Q = {λ

p
1 −p
⊗3
+ (1 −λ)

q
1 −q
⊗3
: λ, p, q ∈[0, 1]}
We see therefore that the eight entries of P ∗∈Q which minimizes D( ˆP||P)
over the set Q is determined by three parameters λ, p, q. For the coin-toss
3.1 The EM Algorithm: General
21
example this looks like:
argmin
0≤λ,p,q≤1
D
 
ˆP || λ

p
1 −p
⊗3
+ (1 −λ)

q
1 −q
⊗3!
= argmax
0≤λ,p,q≤1
1
X
i1=0
1
X
i2=0
1
X
i3=0
ˆPi1i2i3 log

λpni123(1 −p)(3−ni123) + (1 −λ)qni123(1 −q)(3−ni123)
where ni123 = i1 + i2 + i3. Trying to work out an algorithm for minimizing
the unknown parameters λ, p, q would be somewhat ”unpleasant” (and even
more so for other families of distributions H) because of the log-over-a-sum
present in the optimization function — if we could somehow turn this into
a sum-over-log our task would be much easier. We would then be able to
turn the problem into a succession of problems over H rather than a single
problem over Q = P
j λjH.
Another point worth attention is the non-
negativity of the output variables — simply minimizing the relative-entropy
measure under the constraints of the class model Q would not guarantee a
non-negative solution. As we shall see, breaking down the problem into a
successions of problems over H would give us the ”non-negativity for free”
feature.
The technique for turning the log-over-sum into a sum-over-log as part of
ﬁnding the ML solution for a mixture model is known as the Expectation-
Maximization (EM) algorithm introduced by Dempster, Laird and Rubin in
1977. It is based on two ideas: (i) introduce auxiliary variables, and (ii) use
of Jensen’s inequality.
3.1 The EM Algorithm: General
Let D = {x1, ..., xm} represent the training data where xi ∈X is taken from
some instance space X which we leave unspeciﬁed. For now, we leave matters
to be as general as possible and speciﬁcally we do not make independence
assumptions on the data generation process.
The ML problem is to ﬁnd a setting of parameters θ which maximizes
the likelihood P(x1, ..., xm | θ), namely, we wish to maximize P(D | θ) over
parameters θ, which is equivalent to maximizing the log-likelihood:
θ∗= argmax
θ
log P(D | θ) = log

X
y
P(D, y | θ)

,
where y represents the hidden variables. We will denote L(θ) = log P(D | θ).
22
EM Algorithm: ML over Mixture of Distributions
Let q(y | D, θ) be some (arbitrary) distribution of the hidden variables y con-
ditioned on the parameters θ and the input sample D, i.e., P
y q(y | D, θ) =
1. We deﬁne a lower bound on L(θ) as follows:
L(θ)
=
log

X
y
P(D, y | θ)


(3.2)
=
log

X
y
q(y | D, θ)P(D, y | θ)
q(y | D, θ)


(3.3)
≥
X
y
q(y | D, θ) log P(D, y | θ)
q(y | D, θ)
(3.4)
=
Q(q, θ).
(3.5)
The inequality comes from Jensen’s inequality log P
j αjaj ≥P
j αj log aj
when P
j αj = 1. What we have obtained is an ”auxiliary” function Q(q, θ)
satisfying
L(θ) ≥Q(q, θ),
for all distributions q(y | D, θ). The maximization of Q(q, θ) proceeds by
interleaving the variables q and θ as we separately ascend on each set of
variables. At the (t + 1) iteration we ﬁx the current value of θ to be θ(t)
of the t’th iteration and maximize Q(q, θ(t)) over q, and then maximize
Q(q(t+1), θ) over θ:
q(t+1)
=
argmax
q
Q(q, θ(t))
(3.6)
θ(t+1)
=
argmax
θ
Q(q(t+1), θ).
(3.7)
The strategy of the EM algorithm is to maximize the lower bound Q(q, θ)
with the hope that if we ascend on the lower bound function we will also
ascend with respect to L(θ). The claim below guarantees that an ascend on
Q will also generate an ascend on L:
Claim 3 (Jordan-Bishop) The optimal q(y | D, θ(t)) at each step is
P(y | D, θ(t)).
Proof: We will show that Q(P(y | D, θ(t)), θ(t)) = L(θ(t)) which proves the
claim since L(θ) ≥Q(q, θ) for all q, θ, thus the best q-distribution we can
3.1 The EM Algorithm: General
23
hope to ﬁnd is one that makes the lower-bound meet L(θ) at θ = θ(t).
Q(P(y | D, θ(t)), θ(t))
=
X
y
P(y | D, θ(t)) log P(D, y | θ(t))
P(y | D, θ(t))
=
X
y
P(y | D, θ(t)) log P(y | D, θ(t))P(D | θ(t))
P(y | D, θ(t))
=
log P(D | θ(t))
X
y
P(y | D, θ(t))
=
L(θ(t))
The proof provides also the validity for the approach of ascending along
the lower bound Q(q, θ) because at the point θ(t) the two functions coincide,
i.e., the lower bound function at θ = θ(t) is equal to L(θ(t)) therefore if
we continue and ascend along Q(·) we are guaranteed to ascend along L(θ)
as well† — therefore, convergence is guaranteed. It can also be shown (but
omitted here) that the point of convergence is a stationary point of L(θ) (was
shown originally by C.F. JeﬀWu in 1983 years after EM was introduced in
1977) under fairly general conditions. The second step of maximizing over
θ then becomes:
θ(t+1) = argmax
θ
X
y
P(y | D, θ(t)) log P(D, y | θ).
(3.8)
This deﬁnes the EM algorithm. Often the ”Expectation” step is described
as taking the expectation of:
Ey∼P(y | D,θ(t)) [log P(D, y | θ)] ,
followed by a Maximization step of ﬁnding θ that maximizes the expectation
— hence the term EM for this algorithm.
Eqn. 3.8 describes a principle but not an algorithm because in general,
without making assumptions on the statistical relationship between the data
points and the hidden variable the problem presented in eqn. 3.8 is unwieldy.
We will reduce eqn. 3.8 to something more manageable by making the i.i.d.
assumption. This is detailed in the following section.
† this manner of deriving EM was adapted from Jordan and Bishop’s book notes, 2001.
24
EM Algorithm: ML over Mixture of Distributions
3.2 EM with i.i.d. Data
The EM optimization presented in eqn. 3.8 can be simpliﬁed if we assume
the data points (and the hidden variable values) are i.i.d.
P(D | θ) =
n
Y
i=1
P(xi | θ),
P(D, y | θ) =
n
Y
i=1
P(xi, yi | θ),
and
P(y | D, θ) =
n
Y
i=1
P(yi | xi, θ).
For any α(yi) we have:
X
y
α(yi)P(y | D, θ)
=
X
y1
· · ·
X
yn
α(yi)P(y1 | x1, θ) · · · P(yn | xn, θ)
=
X
yi
α(yi)P(yi | xi, θ)
this is because P
yj P(yj | xj, θ) = 1. Substituting the simpliﬁcations above
into eqn. 3.8 we obtain:
θ(t+1) = argmax
θ
k
X
j=1
m
X
i=1
P(yi = αj | xi, θ(t)) log P(xi, yi = αj | θ)
(3.9)
where yi ∈{α1, ..., αk}.
3.3 Back to the Coins Example
We will apply the EM scheme to our running example of mixture of Bernoulli
distributions. We wish to compute
Q(θ, θ(t))
=
X
y
P(y | D, θ(t)) log P(D, y | θ)
=
n
X
i=1
2
X
j=1
P(yi = j | xi, θ(t)) log P(xi, yi = j | θ),
3.3 Back to the Coins Example
25
and then maximize Q() with respect to p, q, λ.
Q(θ, θ′)
=
n
X
i=1

P(yi = 1 | xi, θ′) log P(xi | yi = 1, θ)P(yi = 1 | θ)

+
n
X
i=1

P(yi = 2 | xi, θ′) log P(xi | yi = 2, θ)P(yi = 2 | θ)

=
X
i
h
µi log(λpni(1 −p)(3−ni)) + (1 −µi) log((1 −λ)qni(1 −q)(3−ni))
i
where θ′ stands for θ(t) and µi = P(yi = 1 | xi, θ′). The values of µi are
known since θ′ = (λo, po, qo) are given from the previous iteration.
The
Bayes formula is used to compute µi:
µi
=
P(yi = 1 | xi, θ′) = P(xi | yi = 1, θ′)P(yi = 1 | θ′)
P(xi | θ′)
=
λopni
o (1 −po)(3−ni)
λopni
o (1 −po)(3−ni) + (1 −λo)qni
o (1 −qo)(3−ni)
We wish to compute: maxp,q,λ Q(θ, θ′). The partial derivative with respect
to λ is:
∂Q
∂λ =
X
i
µi
1
λ −
X
i
(1 −µi)
1
1 −λ = 0,
from which we obtain the update formula of λ given µi:
λ = 1
k
n
X
i=1
µi.
The partial derivative with respect to p is:
∂Q
∂p =
X
i
µini
p
−
X
i
µi(3 −ni)
1 −p
= 0,
from which we obtain the update formula:
p =
1
P
i µi
X
i
ni
3 µi.
Likewise the update rule for q is:
q =
1
P
i(1 −µi)
X
i
ni
3 (1 −µi).
To conclude, we start with some initial ”guess” of the values of p, q, λ, com-
pute the values of µi and update iteratively the values of p, q, λ where at the
end of each iteration the new values of µi are computed.
26
EM Algorithm: ML over Mixture of Distributions
3.4 Gaussian Mixture
The Gaussian mixture model assumes that P(x) where x ∈Rd is a linear
combination of Gaussian distributions
P(x) =
k
X
j=1
P(x | y = j)P(y = j)
where
P(x | y = j) =
1
(2π)d/2σd
j
exp
−
∥x−cj∥2
2σ2
j
,
is Normally distributed with mean cj and covariance matrix σ2
j I. Let D =
{x1, ..., xm} be the i.i.d sample data and we wish to solve for the mean
and covariances of the individual Gaussians (the ”factors”) and the mixing
coeﬃcients λj = P(y = j). In order to make clear where the parameters are
located we will write P(x | φj) instead of P(x | y = j) where φj = (cj, σ2
j )
are the mean and variance of the j’th factor. We denote by θ the collection
of mixing coeﬃcients λj and φj, j = 1, ..., k. Let wj
i be auxiliary variables
per point xi and per factor y = j standing for:
wj
i = P(yi = j | xi, θ).
The EM step (eqn. 3.9) is:
θ(t+1) = argmax
θ={λ,φ}
k
X
j=1
m
X
i=1
wj
i
(t) log (λjP(xi | φj))
s.t.
X
j
λj = 1.
(3.10)
Note the constraint P
j λj = 1. The update formula for wj
i is done through
the use of Bayes formula:
wj
i
(t) = P(yi = j | θ(t))P(xi | yi = j, θ(t))
P(xi | θ(t))
= 1
Zi
λ(t)
j P(xi | φ(t)),
where Zi is a scaling factor so that P
j wj
i = 1.
The update formula for λj, cj, σj follow by taking partial derivatives of
eqn. (3.10) and setting them to zero. Taking partial derivatives with respect
3.5 Application Examples
27
to λj, cj and σj we obtain the update rules:
λj
=
1
m
m
X
i=1
wj
i
cj
=
1
P
i wj
i
m
X
i=1
wj
i xi,
σ2
j
=
1
d P
i wj
i
m
X
i=1
wj
i ∥xi −cj∥2.
In other words, the observations xi are weighted by wj
i before a Gaussian is
ﬁtted (k times, one for each factor).
3.5 Application Examples
3.5.1 Gaussian Mixture and Clustering
The Gaussian mixture model is classically used for clustering applications.
In a clustering application one receives a sample of points x1, ..., xm where
each point resides in Rd. The task of the learner (in this case ”unsupervised”
learning) is to group the m points into k sets. Let yi ∈{1, ..., k} where
i = 1, ..., m stands for the required labeling. The clustering solution is an
assignment of values to y1, ..., ym according to some clustering criteria.
In the Gaussian mixture model points are clustered together if they arise
from the same Gaussian distribution. The EM algorithm provides a proba-
bilistic assignment P(yi = j | xi) which we denoted above as wj
i .
3.5.2 Multinomial Mixture and ”bag of words” Application
The multinomial mixture (the coins example we toyed with) is typically used
for representing ”count” data, such as when representing text documents as
high-dimensional vectors. A vector representation of a text document asso-
ciates a word from a ﬁxed vocabulary to a coordinate entry of the vector.
The value of the entry represents the number of times that particular word
appeared in the document. If we ignore the order in which the words ap-
peared and count only their frequency, a set of documents d1, ..., dm and a
set of words w1, ...., wn could be jointly represented by a co-occurence n×m
matrix G where Gij contains the number of times word wi appeared in doc-
ument dj. If we scale G such that P
ij Gij = 1 then we have a distribution
P(w, d). This kind of representation of a set of documents is called ”bag of
words”.
28
EM Algorithm: ML over Mixture of Distributions
For purposes of search and ﬁltering it is desired to reveal additional infor-
mation about words and documents such as to which ”topic” a document
belongs to or to which topics a word is associated with. This is similar to
a clustering task where documents associated with the same topic are to be
clustered together. This can be achieved by considering the topics as the
value of a latent variable y:
P(w, d) =
X
y
P(w, d | y)P(y) =
X
y
P(w | y)P(d | y)P(y),
where we made the assumption that w⊥d | y (i.e., words and documents are
conditionally independent given the topic).
The conditional independent
assumption gives rise to the multinomial mixture model. To be more speciﬁc,
ley y ∈{1, ..., k} denote the k possible topics and let λj = P(y = j) (note
that P
j λj = 1), then the latent class model becomes:
P(w, d) =
k
X
j=1
λjP(w | y = j)P(d | y = j).
Note that P(w | y = j) is a vector which we denote as uj ∈Rn and P(d | y =
j) is also a vector we denote by vj ∈Rm. The term P(w | y = j)P(d | y = j)
stands for the outer-product ujv⊤
j of the two vectors, i.e., is a rank-1 n × m
matrix. The Maximum-Likelihood estimation problem is therefore to ﬁnd
vectors u1, ..., uk and v1, ..., vk and scalars λ1, ..., λk such that the empirical
distribution represented by the unit scaled matrix G is as close as possible
(in relative-entropy measure) to the low-rank matrix P
j λjujv⊤
j subject to
the constraints of non-negativity and P
j λj = 1, uj and vj are unit-scaled
as well (1⊤uj = 1⊤vj = 1).
Let xi = (w(i), d(i)) stand for the i’th example i = 1, ..., q where an
example is a pair of word and document where w(i) ∈{1, ..., n} is the index
to the word alphabet and d(i) ∈{1, ..., m} is the index to the document.
The EM algorithm involves the following optimization step:
θ(t+1)
=
argmax
θ
q
X
i=1
k
X
j=1
P(yi = j | xi, θ(t)) log P(xi, yi = j | θ)
=
argmax
θ
q
X
i=1
k
X
j=1
w(t)
ij log

λjuj,w(i)vj,d(i)

s.t.
1⊤λ = 1⊤uj = 1⊤vj = 1
An update rule for ujr (the r’th entry of uj) is derived below: the derivative
3.5 Application Examples
29
of the Lagrangian is:
∂
∂ujr
" q
X
i=1
w(t)
ij log uj,w(i) −µujr
#
=
∂
∂ujr

N(r) log ujr
X
w(i)=r
w(t)
ij −µujr


=
N(r) P
w(i)=r w(t)
ij
ujr
−µ = 0
where N(r) stands for the frequency of the word wr in all the documents
d1, ..., dm. Note that N(r) is the result of summing-up the r’th row of G and
that the vector N(1), ..., N(n) is the marginal P(w) = P
d P(w, d). Given
the constraint 1⊤uj = 1 we obtain the update rule:
ujr ←
N(r) P
w(i)=r w(t)
ij
Pn
s=1 N(s) P
w(i)=s w(t)
ij
.
Update rules for the remaining unknowns are similarly derived. Once EM
has converged, then P
w(i)=r w∗
ij is the probability of the word wr to belong
to the j’th topic and P
d(i)=s w∗
ij is the probability that the s’th document
comes from the j’th topic.
4
Support Vector Machines and Kernel Functions
In this lecture we begin the exploration of the 2-class hyperplane separation
problem. We are given a training set of instances xi ∈Rn, i = 1, ..., m,
and class labels yi = ±1 (i.e., the training set is made up of “positive”
and “negative” examples). We wish to ﬁnd a hyperplane direction w ∈Rn
and an oﬀset scalar b such that w · xi −b > 0 for positive examples and
w · xi −b < 0 for negative examples — which together means that the
margins yi(w · xi −b) > 0 are positive.
Assuming that such a hyperplane exists, clearly it is not unique.
We
therefore need to introduce another constraint so that we could ﬁnd the
most “sensible” solution among all (inﬁnitley many) possible hyperplanes
which separate the training data. Another issue is that the framework is
very limited in the sense that for most real-world classiﬁcation problems
it is somewhat unlikely that there would exist a linear separating function
to begin with. We therefore need to ﬁnd a way to extend the framework
to include non-linear decision boundaries at a reasonable cost. These two
issues will be the focus of this lecture.
Regarding the ﬁrst issue, since there is more than one separating hyper-
plane (assuming the training data is linearly separable) then the question
we need to ask ourselves is among all those solutions which of them has the
best “generalization” properties? In other words, our goal in constructing
a learning machine is not necessarily to do very well (or perfect) on the
training data, because the training data is merely a sample of the instance
space, and not necessarily a “representative” sample — it is simply a sample.
Therefore, doing well on the sample (the training data) does not necessarily
guarantee (or even imply) that we will do well on the entire instance space.
The goal of constructing a learning machine is to maximize the performance
on the test data (the instances we haven’t seen), which in turn means that
30
4.1 Large Margin Classiﬁer as a Quadratic Linear Programming
31
we wish to generalize “good” classiﬁcation performance on the training set
onto the entire instance space.
A related issue to generalization is that the distribution used to generate
the training data is unknown. Unlike the statistical inference material we
had so far, this time we will not attempt to estimate the distribution. The
reason one can derive optimal learning algorithms yet bypass the need for
estimating distributions would be explained later in the course when PAC-
learning will be introduced. For now we will focus only on the algorithmic
aspect of the learning problem.
The idea is to consider a subset Cγ of all hyperplanes which have a ﬁxed
margin γ where the margin is deﬁned as the distance of the closest training
point to the hyperplane:
γ = min
i
yi(w⊤xi −b)
∥w∥

.
The Support Vector Machine (SVM), ﬁrst introduced by Vapnik and his
colleagues in 1992, seeks a separating hyperplane which simultaneously min-
imizes the empirical error and maximizes the margin. The idea of maximiz-
ing the margin is intuitively appealing because a decision boundary which
lies close to some of the training instances is less likely to generalize well
because the learning machine will be susceptible to small perturbations of
those instance vectors. A formal motivation for this approach is deferred to
the PAC-learning material we will introduce later in the course.
4.1 Large Margin Classiﬁer as a Quadratic Linear Programming
We would ﬁrst like to set up the linear separating hyperplane as an optimiza-
tion problem which is both consistent with the training data and maximizes
the margin induce by the separating hyperplane over all possible consistent
hyperplanes.
Formally speaking, the distance between a point x and the hyperplane is
deﬁned by
| w · x −b |
√w · w
.
Since we are allowed to scale the parameters w, b at will (note that if w ·
x −b > 0 so is (λw) · x −(λb) > 0 for all λ > 0) we can set the distance
between the boundary points to the hyperplane to be 1/√w · w by scaling
w, b such the point(s) with smallest margin (closest to the hyperplane) will
be normalized: | w·x−b |= 1, therefore the margin is simply 2/√w · w (see
Fig. 5.1). Note that argmaxw2/√w · w is equivalent to argmaxw2/(w · w)
32
Support Vector Machines and Kernel Functions
which in turn is equivalent to argminw
1
2w · w.
Since all positive points
and negative points should be farther away from the boundary points we
also have the separability constraints w · x −b ≥1 when x is a positive
instance and w·x−b ≤−1 when x is a negative instance. Both separability
constraints can be combined: y(w · x −b) ≥1. Taken together, we have
deﬁned the following optimization problem:
min
w,b
1
2w · w
(4.1)
subject to
yi(w · xi −b) −1 ≥0
i = 1, ..., m
(4.2)
This type of optimization problem has a quadratic criteria function and
linear inequalities and is known in the literature as a Quadratic Linear Pro-
gramming (QP) type of problem.
This particular QP, however, requires that the training data are linearly
separable — a condition which may be unrealistic. We can relax this condi-
tion by introducing the concept of a “soft margin” in which the separability
holds approximately with some error:
min
w,b,ϵi
1
2w · w + ν
l
X
i=1
ϵi
(4.3)
subject to
yi(w · xi −b) ≥1 −ϵi
i = 1, ..., m
ϵi ≥0
Where ν is some pre-deﬁned weighting factor. The (non-negative) vari-
ables ϵi allow data points to be miss-classiﬁed thereby creating an approx-
imate separation. Speciﬁcally, if xi is a positive instance (yi = 1) then the
“soft” constraint becomes:
w · xi −b ≥1 −ϵi,
where if ϵi = 0 we are back to the original constraint where xi is either a
boundary point or laying further away in the half space assigned to positive
instances. When ϵi > 0 the point xi can reside inside the margin or even in
the half space assigned to negative instances. Likewise, if xi is a negative
instance (yi = −1) then the soft constraint becomes:
w · xi −b ≤−1 + ϵi.
4.1 Large Margin Classiﬁer as a Quadratic Linear Programming
33
)
,
(
b
w
maximize the margin
|
|
2
w
0
>
i!
0
>
i
µ
0
=
j
µ
Fig. 4.1. Separating hyperplane w, b with maximal margin. The boundary points
are associated with non-vanishing Lagrange multipliers µi > 0 and margin errors
are associated with ϵi > 0 where the criteria function encourages a small number
of margin errors.
The criterion function penalizes (the L1-norm) for non-vanishing ϵi thus the
overall system will seek a solution with few as possible “margin errors” (see
Fig. 5.1). Typically, when possible, an L1 norm is preferable as the L2 norm
overly weighs high magnitude outliers which in some cases can dominate
the energy function. Another note to make here is that strictly speaking
the ”right thing” to do is to penalize the margin errors based on the L0
norm ∥ϵ∥0
0 = |{i : ϵi > 0}|, i.e., the number of non-zero entries, and drop
the balancing parameter ν. This is because it does not matter how far away
a point is from the hyperplane — all what matters is whether a point is
classiﬁed correctly or not (see the deﬁnition of empirical error in Lecture 4).
The problem with that is that the optimization problem would no longer be
convex and non-convex problems are notoriously diﬃcult to solve. Moreover,
the class of convex optimization problems (as the one described in Eqn. 4.3)
can be solved in polynomial time complexity.
So far we have described the problem formulation which when solved
would provide a solution with “sensible” generalization properties. Although
we can proceed using an oﬀ-the-shelf QLP solver, we will ﬁrst pursue the
”dual” problem. The dual form will highlight some key properties of the
approach and will enable us to extend the framework to handle non-linear
34
Support Vector Machines and Kernel Functions
decision surfaces at a very little cost. In the appendix we take a brief tour on
the basic principles associated with constrained optimization, the Karush-
Kuhn-Tucker (KKT) theorem and the dual form. Those are recommended
to read before moving to the next section.
4.2 The Support Vector Machine
We return now to the primal problem (eqn. 6.3) representing the maximal
margin separating hyperplane with margin errors:
min
w,b,ϵi
1
2w · w + ν
l
X
i=1
ϵi
subject to
yi(w · xi −b) ≥1 −ϵi
i = 1, ..., m
ϵi ≥0
We will now derive the Lagrangian Dual of this problem. By doing so a
new key property will emerge facilitated by the fact that the criteria func-
tion θ(µ) (note there are no equality constraints thus there is no need for λ)
involves only inner-products of the training instance vectors xi. This prop-
erty will form the key of mapping the original input space of dimension n to
a higher dimensional space thereby allowing for non-linear decision surfaces
for separating the training data.
Note that with this particular problem the strong duality conditions are
satisﬁed because the criteria function and the inequality constraints form a
convex set. The Lagrangian takes the following form:
L(w, b, ϵi, µ) = 1
2w · w + ν
m
X
i=1
ϵi −
m
X
i=1
µi [yi(w · xi −b) −1 + ϵi] −
m
X
i=1
δiϵi
Recall that
θ(µ) = min
w,b,ϵ L(w, b, ϵ, µ, δ).
Since the minimum is obtained at the vanishing partial derivatives of the
Lagrangian with respect to w, b, the next step would be to evaluate those
4.2 The Support Vector Machine
35
constraints and substitute them back into L() to obtain θ(µ):
∂L
∂w
=
w −
X
i
µiyixi = 0
(4.4)
∂L
∂b
=
X
i
µiyi = 0
(4.5)
∂L
∂ϵi
=
ν −µi −δi = 0
(4.6)
From the ﬁrst constraint (4.4) we obtain w = P
i µiyixi, that is, w is de-
scribed by a linear combination of a subset of the training instances. The
reason that not all instances participate in the linear superposition is due
to the KKT conditions: µi = 0 when yi(w · xi −b) > 1, i.e., the instance xi
is classiﬁed correctly and is not a boundary point, and conversely, µi > 0
when yi(w · xi −b) = 1 −ϵi, i.e., when xi is a boundary point or when
xi is a margin error (ϵi > 0) — note that for a margin error instance the
value of ϵi would be the smallest possible required to reach an equality in
the constraint because the criteria function penalizes large values of ϵi. The
boundary points (and the margin errors) are called support vectors thus w is
deﬁned by the support vectors only. The third constraint (4.6) is equivalent
to the constraint:
0 ≤µi ≤ν
i = 1, ..., l,
since δi ≥0. Also note that if ϵi > 0, i.e., point xi is a margin-error point,
then by KKT conditions we must have δi = 0. As a result µi = ν. Therefore
based on the values of µi alone we can make the following classiﬁcations:
• 0 < µi < ν: point xi is on the margin and is not a margin-error.
• µi = ν: points xi is a margin-error point.
• µi = 0: point xi is not on the margin.
Substituting these results/constraints back into the Lagrangian L() we
obtain the dual problem:
max
µ1,...,µm
θ(µ) =
m
X
i=1
µi −1
2
X
i,j
µiµjyiyjxi · xj
(4.7)
subject to
0 ≤µi ≤ν
i = 1, ..., m
m
X
i=1
yiµi = 0
The criterion function θ(µ) can be written in a more compact manner as
36
Support Vector Machines and Kernel Functions
follows: Let M be a l × l matrix whose entries are Mij = yiyjxi · xj then
θ(µ) = µ⊤1 −1
2µ⊤Mµ where 1 is the vector of (1, ..., 1) and µ is the vector
(µ1, ..., µm) and µ⊤is the transpose (row vector). Note that M is positive
deﬁnite, i.e., x⊤Mx > 0 for all vectors x ̸= 0 — a property which will be
important later.
The key feature of the dual problem is not so much that it is simpler
than the primal (in fact it isn’t since the primal has no equality constraints)
or that it has a more “elegant” feel, the key feature is that the problem
is completely described by the inner products of the training instances xi,
i = 1, ..., m. This fact will be shown to be a crucial ingredient in the so called
“kernel trick” for the computation of inner-products in high dimensional
spaces using simple functions deﬁned on pairs of training instances.
4.3 The Kernel Trick
We ended with the dual formulation of the SVM problem and noticed that
the input data vectors xi are represented by the Gram matrix M. In other
words, only inner-products of the input vectors play a role in the dual for-
mulation — there is no explicit use of xi or any other function of xi besides
inner-products. This observation suggests the use of what is known as the
”kernel trick” to replace the inner-products by non-linear functions.
The common principle of kernel methods is to construct nonlinear vari-
ants of linear algorithms by substituting inner-products by nonlinear kernel
functions. Under certain conditions this process can be interpreted as map-
ping of the original measurement vectors (so called ”input space”) onto
some higher dimensional space (possibly inﬁnitely high) commonly referred
to as the ”feature space”. Mathematically, the kernel approach is deﬁned
as follows: let x1, ..., xl be vectors in the input space, say Rn, and con-
sider a mapping φ(x) : Rn →F where F is an inner-product space. The
kernel-trick is to calculate the inner-product in F using a kernel function
k : Rn ×Rn →R, k(xi, xj) = φ(xi)⊤φ(xj), while avoiding explicit mappings
(evaluation of) φ().
Common choices of kernel selection include the d’th order polynomial
kernels k(xi, xj) = (x⊤
i xj + θ)d and the Gaussian RBF kernels k(xi, xj) =
exp(−1
2σ2 ∥xi −xj∥2). If an algorithm can be restated such that the input
vectors appear in terms of inner-products only, one can substitute the inner-
products by such a kernel function. The resulting kernel algorithm can be
interpreted as running the original algorithm on the space F of mapped
objects φ(x).
We know that M of the dual form is positive semi-deﬁnite because M
4.3 The Kernel Trick
37
can be written is M = Q⊤Q where Q = [y1x1, ..., ylxl]. Therefore x⊤Mx =
∥Qx∥2 ≥0 for all choices of x (which means that the eigenvalues of M are
non-negative). If the entries of M are to be replaced with yiyjk(xi, xj) then
the condition we must enforce on the function k() is that it is a positive
deﬁnite kernel function. A positive deﬁnite function is deﬁned such that
for any set of vectors x1, ..., xq and for any values of q the matrix K whose
entries are Kij = k(xi, xj) is positive semi-deﬁnite. Formally, the conditions
for admissible kernels k() are known as Mercer’s conditions summarized
below:
Theorem 4 (Mercer’s Conditions) Let k(x, y) be symmetric and contin-
uous. The following conditions are equivalent:
(i) k(x, y) = P∞
i=1 αiφi(x)φi(y) = φ(x)⊤φ(y) for any uniformly converg-
ing series αi > 0.
(ii) for all ψ() satisfying
R
x ψ2(x)dx < ∞, then
Z
x
Z
y
k(x, y)ψ(x)ψ(y)dxdy ≥0
(iii) for all {xi}q
i=1 and for all q, the matrix Kij = k(xi, xj) is positive
semi-deﬁnite.
Perhaps the non-obvious condition is No. 1 which allows for the feature
map φ() to have inﬁnitely many coordinates (a vector in Hilbert space). For
example, as we shall see below, the kernel exp(−1
2σ2 ∥xi −xj∥2) is an inner-
product of two vectors with inﬁnitely many coordinates. We will consider
next a number of popular kernels.
4.3.1 The Homogeneous Polynomial Kernel
Let x, y ∈Rk and deﬁne k(x, y) = (x⊤y)d where d > 0 is a natural number.
Then, the corresponding feature map φ(x) has
 k+d−1
d

= O(kd) coordinates
which take the value:
φ(x) =
 s
d
n1, ..., nk

xn1
1 · · · xnk
k
!
ni≥0,P
i ni=d
where
 d
n1,...,nk

= d!/(n1! · · · nk!) is the multinomial coeﬃcient (number of
ways to distribute d balls into k bins where the j’th bin hold exactly nj ≥0
balls):
(x1 + ... + xk)d =
X
ni≥0,P
i ni=d

d
n1, ..., nk

xn1
1 · · · xnk
k .
38
Support Vector Machines and Kernel Functions
The dimension of the vector space φ(x) where x ∈Rk can be measured
using the following combinatorial problem: how many arrangements of k−1
partitions to be placed among d items? the answer is
 k+d−1
k−1

=
 k+d−1
d

=
O(kd). For example, k = d = 2 gives us :
(x⊤y)2 = x2
1y2
1 + 2x1x2y1y2 + x2
2y2
2 = φ(x)⊤φ(y),
where φ(x) = (x2
1, x2
2,
√
2x1x2).
4.3.2 The non-homogeneous Polynomial Kernel
The feature map φ(x) contains all monomials whose power is lesser or equal
to d, i.e., P
i ni ≤d. This can be acheived by increasing the dimension
to k + 1 where nk+1 is used to ﬁll the gap between Pk
i=1 ni < d and d.
Therefore the dimension of φ(x) where x ∈Rk would be
 k+d
d

. We have:
(x⊤y + θ)d
=
(x1y1 + ... + xkyk +
√
θ
√
θ)d
=
X
ni≥0,Pk+1
i=1 ni=d

d
n1, ..., nk+1

xn1
1 yn1
1 · · · xnk
1 ynk
1
· θnk+1/2θnk+1/2
Therefore, the entries of the vector φ(x) take the values:
φ(x) =
 s
d
n1, ..., nk+1

xn1
1 · · · xnk
k · θnk+1/2
!
ni≥0,Pk+1
i=1 ni=d
For example, k = d = 2 gives us :
(x⊤y + θ)2 = x2
1y2
1 + 2x1x2y1y2 + x2
2y2
2 + 2θx1y1 + 2θx2y2 + θ = φ(x)⊤φ(y),
where φ(x) = (x2
1, x2
2,
√
2x1x2,
√
2θx1,
√
2θx2,
√
θ). In this example, φ() is a
mapping from R2 to R6 and hyperplanes φ(w)⊤φ(x)−b = 0 in R6 correspond
to conics in R2:
(w2
1)x2
1 + (w2
2)x2 + (2w1w2)x1x2 + (2θw1)x1 + (2θw2)x2 + (θ −b) = 0
Assume we would like to ﬁnd a separating conic (Parabola, Hyperbola,
Ellipse) function rather than a line in R2. The discussion so far suggests we
construct the Gram matrix M in the dual form with the d = 2 polynomial
kernel k(x, y) = (x⊤y+θ)2 for some parameter θ of our choosing. The extra
eﬀort we will need to invest is negligible — simply replace every occurrence
x⊤
i xj with (x⊤
i xj + θ)2.
4.3 The Kernel Trick
39
4.3.3 The RBF Kernel
The function k(x, y) = e−∥x−y∥2/2σ2 known as a Radial Basis Function
(RBF) is a kernel function but with an inﬁnite expansion. Without loss of
generality let σ = 1, then we have:
e−∥x−y∥2/2
=
e−∥x∥2/2e−∥y∥2/2ex⊤y
=
∞
X
j=0
(x⊤y)j
j!
e−∥x∥2/2e−∥y∥2/2
=
∞
X
j=0

e−∥x∥2
2j
√j!1/j
e−∥y∥2
2j
√j!1/j x⊤y


j
=
∞
X
j=0
X
P
i ni=j
e−∥x∥2
2j
√j!1/j

j
n1, ..., nk
1/2
xn1
1 · · · xnk
k
e−∥y∥2
2j
√j!1/j

j
n1, ..., nk
1/2
yn1
1 · · · ynk
k
From which we can see that the entries of the feature map φ(x) are:
φ(x) =

e−∥x∥2
2j
√j!1/j

j
n1, ..., nk
1/2
xn1
1 · · · xnk
k


j=0,..,∞,Pk
i=1 ni=j
4.3.4 Classifying New Instances
By adopting some kernel k() we are in fact mapping x →φ(x), thus we
then proceed to solve for φ(w) and b using some QLP solver. The QLP
solution of the dual form will yield the solution for the Lagrange multipliers
µ1, ..., µm. We saw from eqn. (4.4) that we can express φ(w) as a function
of the (mapped) examples:
φ(w) =
X
i
µiyiφ(xi).
Rather than explicitly representing φ(w) — a task which may be prohibitly
expensive since in general the dimension of the feature space of a polynomial
mapping is
 k+d
d

— we store all the support vectors (those input vectors
with corresponding µi > 0) and use them for the evaluation of test examples:
f(x)
=
sign(φ(w)⊤φ(x) −b) = sign(
X
i
µiyiφ(xi)⊤φ(x) −b)
=
sign(
X
i
µiyik(xi, x) −b).
40
Support Vector Machines and Kernel Functions
We see that the kernel trick enabled us to look for a non-linear separating
surface by making an implicit mapping of the input space onto a higher di-
mensional feature space using the same dual form of the SVM formulation —
the only change required was in the way the Gram matrix was constructed.
The price paid for this convenience is to carry all the support vectors at the
time of classiﬁcation f(x).
A couple of notes may be worthwhile at this point. The constant b can
be recovered from any of the support vectors. Say, x+ is a positive support
vector (but not a margin error, i.e., µi < ν). Then φ(w)⊤φ(x+) −b = 1
from which b can be recovered.
The second note is that the number of
support vectors is typically around 10% of the number of training examples
(empirically). Thus the computational load during evaluation of f(x) may
be relatively high. Approximations have been proposed in the literature by
looking for a reduced number of support vectors (not necessarily aligned
with the training set) — but this is beyond the scope of this course.
The kernel trick gained its popularity with the introduction of the SVM
but since then has taken a life of its own and has been applied to principal
component analysis (PCA), ridge regression, canonical correlation analysis
(CCA), QR factorization and the list goes on. We will meet again with the
kernel trick later on.
5
Spectral Analysis I: PCA, LDA, CCA
In this lecture (and the following one) we will focus on spectral methods for
learning. Today we will focus on dimensionality reduction using Principle
Component Analysis (PCA), multi-class learning using Linear Discriminant
Analysis (LDA) and Canonical Correlation Analysis (CCA). In the next
lecture we will focus on spectral clustering methods.
Dimensionality reduction appears when the dimension of the input vector
is very large (imagine pixels in an image, for example) while the coordi-
nate measurements are highly inter-dependent (again, imagine the redun-
dancy present among neighboring pixels in an image). High dimensional
data impose computational eﬃciency challenges and often translate to poor
generalization abilities of the learning engine (see lectures on PAC). A di-
mensionality reduction can also be viewed as a feature extraction process
where one takes as input a large feature set (the original measurements)
and creates from them a much smaller number of new features which are
then fed into the learning engine.
In this lecture we will focus on feature extraction from a very speciﬁc (and
constrained) stanpoint. We would be looking for a mixing (linear combina-
tion) of the input coordinates such that we obtain a linear projection from
Rn to Rq for some q < n. In doing so we wish to reduce the redundancy
while preserving as much as possible the variance of the data. From a sta-
tistical standpoint this is achieved by transforming to a new set of variables,
called principal components, which are uncorrelated so that the ﬁrst few
retain most of the variation present in all of the original coordinates. For
example, in an image processing application the input images are highly re-
dundant where neighboring pixel values are highly correlated. The purpose
of feature extraction would be to transform the input image into a vector of
output components with the least redundancy possible. Form a geometric
standpoint, this is achieved by ﬁnding the ”closest” (in least squares sense)
41
42
Spectral Analysis I: PCA, LDA, CCA
linear q-dimensional susbspace to the m sample points S. The new sub-
space is a lower dimensional ”best approximation” to the sample S. These
two, equivalent, perspectives on data compression (dimensionality reduc-
tion) form the central idea of principal component analysis (PCA) which
probably the oldest (going back to Pearson 1901) and best known of the
techniques of multivariate analysis in statistics. The computation of PCA
is very simple and the deﬁnition is straightforward, but has a wide variety
of diﬀerent applications, a number of diﬀerent derivations, quite a number
of diﬀerent terminologies (especially outside the statistical literature) and is
the basis for quite a number of variations on the basic technique.
We then extend the variance preserving approach for data representation
for labeled data sets. We will describe the linear classiﬁer approach (sepa-
rating hyperplane) form the point of view of looking for a hyperplane such
that when the data is projected onto it the separation is maximized (the dis-
tance between the class means is maximal) and the data within each class is
compact (the variance/spread is minimized). The solution is also produced,
just like PCA, by a spectral analysis of the data. This approach goes under
the name of Fisher’s Linear Discriminant Analysis (LDA).
What is common between PCA and LDA is (i) the use of spectral ma-
trix analysis — i.e., what can you do with eigenvalues and eigenvectors of
matrices representing subspaces of the data? (ii) these techniques produce
optimal results for normally distributed data and are very easy to imple-
ment. There is a large variety of uses of spectral analysis in statistical and
learning literature including spectral clustering, Multi Dimensional Scaling
(MDS) and data modeling in general. Another point to note is that this is
the ﬁrst time in the course where the type of data distribution plays a role
in the analysis — the two techniques are deﬁned for any distribution but
are optimal only under the Gaussian distribution.
We will also describe a non-linear extension of PCA known as Kernel-
PCA, but the focus would be mostly on PCA itself and its analysis from
a couple of vantage points: (i) PCA as an optimal reconstruction after a
dimension reduction, i.e., data compression, and (ii) PCA for redundancy
reduction (decorrelation) of the output components.
5.1 PCA: Statistical Perspective
Let x1, ..., xm ∈Rn be our sample data S of vectors in Rn, arranged as
columns of a matrix A. It will be convenient to assume that the data is
centered, i.e., P xi = 0. If the data is not centered we can always center it
by computing the mean vector µ = (1/m) P
i xi and replace the original data
5.1 PCA: Statistical Perspective
43
sample with the new sample xi −µ. In a statistical sense, the coordinates
of the vector x ∈Rn are considered as random variables, thus a row in the
matrix A is the sample of values of a particular random variable, drawn from
some unknown probability distribution, associated with the row position.
We wish to ﬁnd vectors u1, ..., uq (arranged as columns of a matrix U),
where q ≤min(n, m), such that the new feature measurements y = U⊤x
(who are the result of linear combinations u⊤
1 x, ..., u⊤
q x of the original feature
measurements x) have certain desirable properties.
The idea property to seek from the new coordinates y is statistical inde-
pendence, i.e., P(y1, .., yq) = P(y1)···P(yq) which would mean that we have
removed the redundancy of the original data x in the best possible manner.
This goal, however, is too much to ask from a linear transformation and
instead we would ask for a weaker property to hold: that the pairwise co-
variance cov(yi, yj) = 0 vanishes, i.e., that the covariance matrix on the new
coordinates is diagonal. A diagonal covariance insures some redundancy re-
moval, but not as good as statistical independence. However, when the data
is Normally distributed P(x) ∼N(µ, Σ) with mean µ and covariance Σ, then
the transformation which diagonalizes the covariance matrix also guarantees
statistical independence. Among all transformations that de-correlate the
data we will seek the one that maximizes the spread (variance) of the sample
data after being projected onto the new axes vectors.
5.1.1 Maximizing the Variance of Output Coordinates
The property we would like to maximize is that the projection of the sample
data on the new axes is as spread as possible. To start this analysis, assume
q = 1, i.e., the n components of the input vector x are reduced to a single
output component y = u⊤x. We are looking for a single vector u ∈Rn
whose direction maximizes the variance of the output component y.
Formally, we are looking for a unit vector u which maximizes P
i(u⊤xi)2
(see Appendix A for basic statistical deﬁnitions and note that E[y] = 0
because P
i u⊤xi = u⊤
i (P
i xi) = 0). In other words, the projected points
onto the axis represented by the vector u are as spread as possible (in a
least squares sense). In vector notation, the optimization problem takes the
following form:
max
u
1
2∥u⊤A∥2
subject to
1
2u⊤u = 1
The Lagrangian of the problem is:
L(u, λ) = 1
2u⊤AA⊤u −λ(1
2u⊤u −1)
44
Spectral Analysis I: PCA, LDA, CCA
By taking the partial derivative ∂L/∂u = 0 we obtain the following necessary
condition (see Appendix B):
AA⊤u = λu,
which tells us that u is an eigenvector of the n × n (symmetric and positive
deﬁnite) matrix AA⊤. There are n eigenvectors associated with AA⊤and
we can easily convince ourselves that we are looking for the one associated
with the maximal eigenvalue: substitute λu instead of AA⊤u in the criterion
function u⊤AA⊤u to obtain λ(u⊤u) = λ and since the eigenvalues must be
positive (since AA⊤is positive deﬁnite), then the optimum is obtained for
the maximal eigenvalue. The leading eigenvector u of AA⊤is called the ﬁrst
principal axis of the data sample represented by the columns of the matrix
A, and y = u⊤x is called the ﬁrst principal component of the data sample.
For convenience, we denote u1 = u and λ1 = λ as the leading eigenvector
and eigenvalue of AA⊤. Next, we look for y2 = u⊤
2 x which is uncorrelated
with y1 = u⊤
1 x and which has maximum variance (and so on for u3, ..., uq).
Two random variables are uncorrelated if their covariance vanishes.
By
deﬁnition of covariance (see Appendix A) we obtain:
Cov(y1y2)
=
X
i
(u⊤
1 xi)(u⊤
2 xi) = u⊤
1 (
X
i
xix⊤
i )u2
=
u⊤
1 AA⊤u2 = u⊤
2 AA⊤u1 = λ1u⊤
1 u2 = 0
We can therefore use the condition u⊤
1 u2 = 0 to specify zero correlation
between y1, y2. The functional to be optimized becomes:
max
u2
1
2∥u⊤
2 A∥2
subject to
1
2u⊤
2 u2 = 1,
u⊤
1 u2 = 0,
with the Lagrangian being:
L(u2, λ, δ) = 1
2u⊤
2 AA⊤u2 −λ(1
2u⊤
2 u2 −1) −δu⊤
1 u2.
By taking the partial derivative with respect to u2 we obtain the necessary
condition:
AA⊤u2 −λu2 −δu1 = 0.
Multiply the equation by u1 from the left:
u⊤
1 AA⊤u2 −λu⊤
1 u2 −δu⊤
1 u1 = 0,
and noting from above that u⊤
1 AA⊤u2 = u⊤
1 u2 = 0 we obtain δ = 0. As a
result we obtain:
AA⊤u2 = λu2,
5.1 PCA: Statistical Perspective
45
so once more we have that λ, u2 form an eigenvalue/eigenvector pair of AA⊤.
As before, λ should be as large as possible from the remaining spectral de-
composition. By induction, it can be shown that the remaining principal
vectors u3, ..., uq are the decreasing order eigenvactors of AA⊤and the vari-
ance of the i’th principal component yi = u⊤
i x is λi.
Taken together, the PCA is the solution of the following optimization
problem:
max
u1,...,uq
1
2
X
i
∥u⊤
i A∥2
subject to
u⊤
i ui = 1,
u⊤
i uj = 0,
i ̸= j = 1, ..., q.
It will be useful for later to write the optimization function in a more concise
manner as follows. Let U be the n × q matrix whose columns are ui and
D = diag(λ1, ..., λq) is an q×q diagonal matrix and λ1 ≥λ2 ≥... ≥λq. Then
from above we have that U⊤U = I and AA⊤U = UD. Using the fact that
trace(xy⊤) = x⊤y, trace(AB) = trace(BA) and trace(A+B) = trace(A)+
trace(B) we can convert P
i ∥u⊤
i A∥2 to trace(U⊤AA⊤U) as follows:
X
i
u⊤
i AA⊤ui
=
X
i
trace(A⊤uiu⊤
i A) = trace(A⊤(
X
i
uiu⊤
i )A)
=
trace(A⊤UU⊤A) = trace(U⊤AA⊤U)
Thus, PCA becomes the solution of the following optimization function:
max
U∈Rn×q trace(U⊤AA⊤U)
subject to
U⊤U = I.
(5.1)
The solution, as saw above, is that U = [u1, ..., uq] consists of the decreasing
order eigenvectors of AA⊤. At the optimum, trace(U⊤AA⊤U) is equal to
trace(D) which is equal to the sum of eigenvalues λ1 + ... + λq.
It is worthwhile noting that when q = n, UU⊤= U⊤U = I, and the PCA
transform is a change of basis in Rn known as Karhunen-Loeve transform.
To conclude, the PCA transform looks for q orthogonal direction vectors
(called the principal axes) such that the projection of input sample vectors
onto the principal directions has the maximal spread, or equivalently that
the variance of the output coordinates y = U⊤x is maximal. The principal
directions are the leading (with respect to descending eigenvalues) q eigen-
vectors of the matrix AA⊤. When q = n, the principal directions form a
basis of Rn with the property of de-correlating the data and maximizing the
variance of the coordinates of the sample input vectors.
46
Spectral Analysis I: PCA, LDA, CCA
5.1.2 Decorrelation: Diagonalization of the Covariance Matrix
In the previous section we saw that PCA generates a new coordinate system
y = U⊤x where the coordinates y1, ..., yq of x in the new system are uncorre-
lated. This means that the covariance matrix over the principle components
should be diagonal. In this section we will explore this perspective in more
detail.
The covariance matrix Σx of the sample data x1, ..., xm with zero mean
is
(1/m)
X
i
xix⊤
i = (1/m)AA⊤,
therefore the matrix AA⊤we derived above is a scaled version of the co-
variance of the sample data (see Appendix A). The scale factor 1/m was
unimportant in the process above because the eigenvectors are of unit norm,
thus any scale of AA⊤would produce the same set of eigenvectors.
The oﬀ-diagonal entries of the covariance matrix Σx represent the corre-
lation (a measure of statistical dependence) between the i’th and j’th com-
ponent vectors, i.e., the entries of the input vectors x. The existence of
correlations among the components (features) of the input signal is a sign
of redundancy, therefore from the point of view of transforming the input
representation into one which is less redundant, we would like to ﬁnd a
transformation y = U⊤x with an output representation y which is associ-
ated with a diagonal covariance matrix Σy, i.e., the components of y are
uncorrelated.
Formally, Σy = (1/m) P
i yiy⊤
i = (1/m)U⊤AA⊤U, therefore we wish to
ﬁnd an n × q matrix for which U⊤AA⊤U is diagonal. If in addition, we
would require that the variance of the output coordinates is maximized,
i.e., trace(U⊤AA⊤U) is maximal (but then we need to constrain the length
of the column vectors of U, i.e., set ∥ui∥= 1) then we would get a unique
solution for U where the columns are orthonormal and are deﬁned as the ﬁrst
q eigenvectors of the covariance matrix Σx. This is exactly the optimization
problem deﬁned by eqn. (5.1).
We see therefore that PCA “decorrelates” the input data. Decorrelation
and statistical independence are not the same thing. If the coordinates are
statistically independent then the covariance matrix is diagonal†, but it does
not follow that uncorrelated variables must be statistically independent —
covariance is just one measure of dependence. In fact, the covariance is a
measure of pairwise dependency only. However, it is a fact that uncorrelated
† σxy = P
x
P
y(x −µx)(y −µy)p(x, y) = P
x
P
y(x −µx)(y −µy)p(x)(p(y) = (P
x(x −
µx)p(x))(P
y(y −µy)p(y)) = 0
5.2 PCA: Optimal Reconstruction
47
variables are statistically independent if they have a multivariate normal
distribution (a Gaussian). In other words, if the sample data x are drawn
from a probability distribution p(x) which has Gaussian form, the PCA
transforms the sample data into a statistically independent set of variables
y = U⊤x. The details are explained below.
Recall that a multivariate normal distribution of the random variables
x = (x1, ..., xn)⊤is deﬁned as p(x) ≈N(µ, Σ):
p(x) =
1
(2π)n/2|Σ|1/2 e−1
2 (x−µ)⊤Σ−1(x−µ).
Also recall that a linear combination of the variables produces also a normal
distribution N(U⊤µ, U⊤ΣU):
Σy =
X
y
(y−µy)(y−µy)⊤=
X
x
(U⊤x−U⊤µx)(U⊤x−U⊤µx)⊤= U⊤ΣxU,
therefore choose U such that Σy = U⊤ΣU is a diagonal matrix Σy =
diag(σ2
1, ..., σ2
n). We have in that case:
p(x) =
1
(2π)n/2 Q
i σi
e−1
2
P
i
“ xi−µi
σi
”2
which can be written as a product of univariate normal distributions pxi(xi):
p(x) =
n
Y
i=1
1
(2π)1/2σi
e−1
2
“ xi−µi
σi
”2
=
n
Y
i=1
pxi(xi),
which proves the assertion that decorrelated normally distributed variables
are statistically independent.
5.2 PCA: Optimal Reconstruction
A diﬀerent, yet equivalent, perspective on the PCA transformation is as an
optimal reconstruction (in a least squares sense) after a dimension reduction.
We are given a sample data as before x1, ..., xm and we are looking for a small
number of orthonormal principal vectors u1, ..., uq where q < min(n, k)
which deﬁne a q-dimensional linear subspace of Rn which best approximate
the original input vectors in a least squares sense.
In other words, the
projection ˆxi of the sample points xi onto the q-dimensional subspace should
minimize P
i ∥xi −ˆxi∥2 over all possible q-dimensional subspaces of Rn.
Let U be the subspace spanned by the principal vectors (columns of U)
and let P be the n × n projection matrix mapping a point x ∈Rn onto its
projection ˆx ∈U. From the deﬁnition of projection, the vector x −ˆx must
48
Spectral Analysis I: PCA, LDA, CCA
be orthogonal to the subspace U. Let y = (y1, ..., yq) be the coordinates of ˆx
with respect to the principal vectors, i.e., Uy = ˆx. Then, from orthogonality
we have that (x −Uy)⊤Uw = 0 for all vectors w ∈Rn. Since this is true
for all w then U⊤Uy −U⊤x = 0. Therefore, y = (U⊤U)−1U⊤x and as a
result the projection matrix P becomes:
P = U(U⊤U)−1U⊤,
satisfying Px = ˆx. In the case the columns of U are orthonormal, U⊤U = I,
we have P = UU⊤. We are ready now to describe the optimization problem
on U: we wish to ﬁnd an orthonormal set of principal vectors, U⊤U = I,
such that P
i ∥xi −UU⊤xi∥2 is minimized.
Note that P
i ∥xi −UU⊤xi∥2 = ∥A −UU⊤A∥2
F where ∥B∥2
F = P
i,j b2
ij
is the square Frobenious norm of a matrix.
The optimal reconstruction
problem therefore becomes:
min
U ∥A −UU⊤A∥2
F
subject to
U⊤U = I.
We will show now that:
argmin
U
∥A −UU⊤A∥2
F = argmax
U
trace(U⊤AA⊤U),
which shows that the optimal reconstruction problem is solved by PCA
(recall Eqn. 5.1).
From the identity ∥B∥2
F = trace(BB⊤), we have:
∥A −UU⊤A∥2
F = trace((A −UU⊤A)(A −UU⊤A)⊤).
Expanding the right hand side gives us:
trace((A −UU⊤A)(A −UU⊤A)⊤)
=
trace(AA⊤) −trace(AA⊤UU⊤)
−
trace(UU⊤AA⊤) + trace(UU⊤AA⊤UU⊤)
The second and third term are equal (commutativity of trace) and is also
equal to the 4th term due to commutativity of the trace and U⊤U = I.
Taken together:
∥A −UU⊤A∥2
F = trace(AA⊤) −trace(U⊤AA⊤U).
To conclude, we have proven that by taking the ﬁrst q eigenvectors of AA⊤
we obtain a linear subspace which is as close as possible (in a least squares
sense) to the original sample data. Hence, PCA can be viewed as a vehi-
cle for optimal reconstruction after dimension reduction. The optimization
5.3 The Case n >> m
49
problem whose solution is the leading q eigenvectors of AA⊤is described in
eqn. 5.1:
max
U∈Rn×q trace(U⊤AA⊤U)
subject to
U⊤U = I.
5.3 The Case n >> m
Consider the situation where n, the dimension of the input vectors, is rela-
tively large compared to the number of sample vectors m. For example, con-
sider input vectors representing 50 × 50 sized images of faces, i.e., n = 2500,
where m = 100. In other words, we are looking for a small number of “face
templates” (known as “eigenfaces”) which approximate well the original set
of 100 face images. In this case, AA⊤is very large, 2500×2500, yet the num-
ber of non-vanishing eigenvalues cannot be higher than 100. Given that the
eigendecomposition process is O(25003), the computational burden would
be very high. However, it is possible to perform an eigendecomposition on
A⊤A (a 100 × 100 matrix) instead, as shown next.
Let the columns of Q be the ﬁrst q < m eigenvectors of A⊤A, i.e., A⊤AQ =
QD where D is diagonal containing the corresponding eigenvalues. After
pre-multiplying both sides by A we obtain:
AA⊤(AQ) = (AQ)D,
from which we conclude that AQ contains the ﬁrst q eigenvectors (but un-
normalized) of AA⊤. We have therefore that U = AQD−1
2 because:
U⊤U = D−1
2 Q⊤A⊤AQD−1
2 = D−1
2 DD−1
2 = I,
where we used the fact that Q⊤A⊤AQ = D. Note that eigenvalues of A⊤A
and AA⊤are the same (because AA⊤(AQD−1
2 ) = (AQD−1
2 )D).
5.4 Kernel PCA
We can take the case n >> m described in the previous section one step fur-
ther and consider such large values of n which are practically uncomputable
— a situation which results when mapping the original input vectors to a
high dimensional space: φ(x) where φ : Rn →F for which dim(F) >> n.
For example, φ(x) representing the d’th order monomials of the coordinates
of x, i.e., dim(F) =
 n+d−1
d

which is exponential in d.
The mappings
of interest are those which are paired with a non-linear kernel function:
k(x, x′) = φ(x)⊤φ(x′).
Performing PCA on A = [φ(x1), ..., φ(xm)] is equivalent to ﬁnding the
50
Spectral Analysis I: PCA, LDA, CCA
non-linear surface in Rn (the nature of the non-linearity depends on the
choice of φ()) which best approximates the original sample data x1, ..., xm.
The problem is that AA⊤is not computable — however A⊤A is computable
because (A⊤A)ij = k(xi, xj).
From the previous section, U = AQD−1
2 = AV contains the ﬁrst q eigen-
vectors of AA⊤(where Q and D are computable).
Since A itself is not
computable we cannot represent U explicitly, but we can project a new
vector φ(x) onto the principal directions u1, ..., uq and obtain the principal
components, i.e., the output vector y = U⊤φ(x), as follows.
y = U⊤φ(x) = V ⊤A⊤φ(x) = V ⊤






k(x1, x)
.
.
.
k(xm, x)






.
Given the principal components (entries of y = U⊤φ(x) of φ(x)) we can
measure, for example, the distance between φ(x) and the projection
ˆ
φ(x) =
UU⊤φ(x) = Uy onto the linear subspace spanned by u1, ..., uq (without the
need to explicitly compute the principal axes ui), as follows.
∥φ(x) −
ˆ
φ(x)∥2
=
φ(x)⊤φ(x) +
ˆ
φ(x)
⊤ˆ
φ(x) −2φ(x)⊤ˆ
φ(x)
=
k(x, x) + y⊤U⊤Uy −2φ(x)⊤(UU⊤φ(x))
=
k(x, x) −y⊤y −2y⊤y
=
k(x, x) −∥y∥2
5.5 Fisher’s LDA: Basic Idea
We now extend the variance preserving approach for data representation for
labeled data sets. We will focus on 2-class sets and look for a separating
hyperplane:
f(x) = w⊤x + b,
such that x belongs to the ﬁrst class if f(x) > 0 and x belongs to the second
class if f(x) < 0. In the statistical literature this type of function is called
a linear discriminant function. The decision boundary is given by the set
of points satisfying f(x) = 0 which is a hyperplane. Fisher’s (1936) Linear
Discriminant Analysis (LDA) is a variance preserving approach for ﬁnding
a linear discriminant function.
5.5 Fisher’s LDA: Basic Idea
51
Fig. 5.1. Linear discriminant analysis based on class centers alone is not suﬃcient.
Seeking a projection which maximizes the distance between the projected centers
will prefer the horizontal axis over the vertical, yet the two classes overlap on the
horizontal axis. The projected distance along the vertical axis is smaller yet the
classes are better separated. The conclusion is that the sample variance of the two
classes must be taken into consideration as well.
We will then introduce another popular statistical technique called Canon-
ical Correlation Analysis (CCA) for learning the mapping between input and
output vectors using the notion ”angle” between subspaces.
What is common in the three techniques PCA, LDA and CCA is the use
of spectral matrix analysis — i.e., what can you do with eigenvalues and
eigenvectors of matrices representing subspaces of the data? These tech-
niques produce optimal results for normally distributed data and are very
easy to implement. There is a large variety of uses of spectral analysis in
statistical and learning literature including spectral clustering, Multi Di-
mensional Scaling (MDS) and data modeling in general.
To appreciate the general idea behind Fisher’s LDA consider Fig. 5.1. Let
the centers of classes one and two be denoted by µ1 and µ2 respectively. A
linear discriminant function is a projection onto a 1D subspace such that
the classes would be separated the most in the 1D subspace. The obvious
ﬁrst step in this kind of analysis is to make sure that the projected centers
ˆµ1, ˆµ2 would be separated as much as possible. We can easily see that the
direction of the 1D subspace should be proportional to µ1 −µ2 as follows:
(ˆµ1 −ˆµ2)2 =
w⊤µ1
∥w∥−w⊤µ2
∥w∥
2
=
 w⊤
∥w∥(µ1 −µ2)
2
.
The right-hand term is maximized when w ≈µ1 −µ2. As illustrated in
52
Spectral Analysis I: PCA, LDA, CCA
Fig. 5.1, this type of consideration is not suﬃcient to capture separability
in the projected subspace because the spread (variance) of the data points
around their centers also play an important role. For example, the horizontal
axis in the ﬁgure separates the centers better than the vertical axis but on
the other hand does a worse job in separating the classes themselves because
of the way the data points are spread around their centers. The argument
in favor of separating the centers would work if the data points were living
in a hyper-sphere around the centers, but will not be suﬃcient otherwise.
The basic idea behind Fisher’s LDA is to consider the sample covariance
matrix of the individual classes as well as their centers, in the following way.
The optimal 1D projection would that which maximizes the variance of the
projected centers while minimizes the variance of the projected data points
of each class separately. Mathematically, this idea can be implemented by
maximizes the following ratio:
max
w
(ˆµ1 −ˆµ2)2
s2
1 + s2
2
,
where s2
1 is the scaled variance of the projected points of the ﬁrst class:
s2
1 =
X
xi∈C1
( ˆxi −ˆµ1)2,
and likewise,
s2
2 =
X
xi∈C2
( ˆxi −ˆµ2)2,
where ˆx = w⊤
∥w∥xi + b.
We will now formalize this approach and derive its solution. We will begin
with a general description of a multiclass problem where the sample data
points belong to q diﬀerent classes, and later focus on the case of q = 2.
5.6 Fisher’s LDA: General Derivation
Let the sample data points S be members of q classes C1, ..., Cq where the
number of points belonging to class Ci is denoted by li and the total number
of the training set is l = P
i li. Let µj denote the center of class Ci and µ
denote the center of the complete training set S:
µj
=
1
lj
X
bfxi∈Cj
xi
µ
=
1
l
X
xi∈S
xi
5.6 Fisher’s LDA: General Derivation
53
Let Aj be the matrix associated with class Cj whose columns consists of the
mean shifted data points:
Aj = [x1 −µj, ..., xlj −µj]
xi ∈Cj.
Then,
1
lj AjA⊤
j is the covariance matrix associated with class Cj. Let Sw
(where ”w” stands for ”within”) be the sum of the class covariance matrices:
Sw =
q
X
i
1
lj
AjA⊤
j .
From the discussion in the previous section, it is
1
∥w∥2 w⊤Sww which we
wish to minimize. To see why this is so, note
X
xi∈Cj
( ˆxi −ˆµj)2 =
X
xi∈Cj
w⊤(xi −µj)2
∥w∥2
=
1
∥w∥2 w⊤AjA⊤
j w.
Let B be the matrix holding the class centers:
B = [µ1 −µ, ..., µq −µ],
and let Sb = 1
qBB⊤(where ”b” stands for ”between”). From the discussion
above it is
1
∥w∥2 w⊤Sbw = P
i(ˆµi −ˆµ)2 which we wish to maximize. Taken
together, we wish to maximize the ratio (called ”Rayleigh’s quotient”):
max
w J(w) = w⊤Sbw
w⊤Sww.
The necessary condition for optimality is:
∂J
∂w = Sbw(w⊤Sww) −Sww(w⊤Sbw)
(w⊤Sww)2
= 0,
From which we obtain the generalized eigensystem:
Sbw = J(w)Sww.
(5.2)
That is, w is the leading eigenvector of S−1
w Sb (assuming Sw is invertible).
The general case of ﬁnding q such axes involves ﬁnding the leading general-
ized eigenvectors of (Sb, Sw) — the derivation is out of scope of this lecture.
Note that since S−1
w Sb is not symmetric there may be no real-value solution,
which is a complication will not pursue further in this course. Instead we
will focus now on the 2-class (q = 2) setting below.
54
Spectral Analysis I: PCA, LDA, CCA
5.7 Fisher’s LDA: 2-class
The general derivation is simpliﬁed when there are only two classes. The
covariance matrix BB⊤becomes a rank-1 matrix:
BB⊤= (µ1 −µ)(µ1 −µ)⊤+ (µ2 −µ)(µ2 −µ)⊤= (µ1 −µ2)(µ1 −µ2)⊤.
As a result, BB⊤w is a vector in direction µ1 −µ2. Therefore, the solution
for w from eqn. 5.2 is:
w ∼= S−1
w (µ1 −µ2).
The decision boundary w⊤(x −µ) = 0 becomes:
x⊤S−1
w (µ1 −µ2) −1
2(µ1 + µ2)⊤S−1
w (µ1 −µ2) = 0.
(5.3)
This decision boundary will surface again in the course when we consider
Bayseian inference.
It will be shown that this decision boundary is the
Maximum Likelihood solution in the case where the two classes are normally
distributed with means µ1, µ2 and with the same covariance matrix Sw.
5.8 LDA versus SVM
Both LDA and SVM search for a so called ”optimal” linear discriminant
function, what is the diﬀerence? The heart of the matter lies in the deﬁnition
of what constitutes a suﬃcient compact representation of the data. In LDA
the assumption is that each class can be represented by its mean vector and
its spread (i.e., covariance matrix). This is true for normally distributed
data — but not true in general. This means that we should expect that
LDA will produce the optimal discriminant linear function when each of the
classes are normally distributed.
With SVM, on the other hand, there is no assumption on how the data
is distributed. Instead, the emerging result is that the data is represented
by the subset of data points which lie on the boundary between the two
classes (the so called support vectors). Rather than making a parametric
assumption on how the data can be captured (i.e., mean and covariance) the
theory shows that the data can be captured by a special subset of points. The
tools, as a result, are naturally more complex (quadratic linear programming
versus spectral matrix analysis) — but the advantage is that optimality is
guaranteed without making assumptions on the distribution of the data (i.e.,
distribution free). It can be shown that SVM and LDA would produce the
same result if the class data is normally distributed.
5.9 Canonical Correlation Analysis
55
5.9 Canonical Correlation Analysis
CCA is a technique for learning a mapping f(x) = y where x ∈Rk and
y ∈Rs using the notion of subspace similarity (an extension of the inner
product between two vectors) from a training set of (xi, yi), i = 1, ..., n. Such
a mapping, where y can be any point in Rk as opposed to a discrete set of
labels, is often referred to as a ”regression” (as opposed to ”classiﬁcation”).
Like in PCA and LDA, the approach would be to look for projection axes
such that the projection of the input and output vectors on those axes satisfy
certain requirements — and like PCA and LDA the tools we would be using
is matrix spectral analysis.
It will be convenient to stack our vectors as rows of an input matrix A and
output matrix B. Let A be an n × k matrix whose rows are x⊤
1 , ..., x⊤
n and
B is the n × s matrix whose rows are y⊤
1 , ..., y⊤
n . Consider vectors u ∈Rk
and v ∈Rs and project the input and output data onto them producing
Au = (x⊤
1 u, ..., x⊤
n u) and Bv. The requirement we would like to place on
the projection axes is that Au ≈Bv, or in other words that (Au)⊤(Bv)
is maximal. The requirement therefore is that the projection of the input
points onto the u axis is similar to the projection of the output points
onto the v axis. If we extend this notion to multiple axes u1, ..., uq (not
necessarily orthogonal) and v1, ..., vq where q ≤min(k, s) our requirement
becomes that the new coordinates of the input points projected onto the
subspace spanned by the u vectors are similar to the new coordinates of
the output points projected onto the subspace spanned by the v vectors.
In other words, we wish to ﬁnd two q-dimensional subspaces one of Rk and
the other of Rs such that the two sets of projected points are as aligned as
possible.
CCA goes a step further and makes the assumption that the input/output
relationship is solely determined by the relation (angles) between the column
spaces of A, B. In other words, the particular columns of A are not really
important, what is important is the space UA spanned by the columns.
Since g = Au is a point in UA (a linear combination of the columns of
A) and h = Bv is a point in UB, then g⊤h is the cosine angle, cos(φ)
between the two axes provided that we normalize the vectors g and h. If
we continue this line of reasoning recursively, we obtain a set of angles
0 ≤θ1 ≤... ≤θq ≤(π/2), called ”principal angles”, between the two
subspaces uniquely deﬁned as:
cos(θj) = max
g∈UA max
h∈UB
g⊤h
(5.4)
56
Spectral Analysis I: PCA, LDA, CCA
subject to:
g⊤g = h⊤h = 1,
h⊤hi = 0, g⊤gi = 0,
i = 1, ..., j −1
As a result, we obtain the following optimization function over axes u, v:
max
u,v u⊤A⊤Bv
s.t.
∥Au∥2 = 1,
∥Bv∥2 = 1.
To solve this problem we ﬁrst perform a ”QR” factorization of A and B. A
”QR” factorization of a matrix A is a Grahm-Schmidt process resulting in
an orthonormal set of vectors arranged as the columns of a matrix QA whose
column space is equal to the column space of A, and a matrix RA which
contains the coeﬃcients of the linear combination of the columns of QA such
that A = QARA. Since orthoganilzation is not unique, the Grahm-Schmidt
process perfroms the orthogonalization such that RA is an upper-diagonal
matrix. Likewise let B = QBRB. Because the column spaces of A and QA
are the same, then for every u there exists a ˆu such that Au = QAˆu. Our
optimization problem now becomes:
max
ˆu,ˆv
ˆu⊤Q⊤
AQBˆv
s.t.
∥ˆu∥2 = 1,
∥ˆv∥2 = 1.
The solution of this problem is when ˆu and ˆv are the leading singular vectors
of Q⊤
AQB. The singular value decomposition (SVD) of any matrix E is a
decomposition E = UDV ⊤where the columns of U are the leading eigen-
vectors of EE⊤, the rows of V ⊤are the leading eigenvectors of E⊤E and
D is a diagonal matrix whose entries are the corresponding square eigen-
values (note that the eigenvalues of EE⊤and E⊤E are the same). The
SVD decomposition has the property that if we keep only the ﬁrst q leading
eigenvectors then UDV ⊤is the closest (in least squares sense) rank q matrix
to E.
Therefore, let ˆUD ˆV ⊤be the SVD of Q⊤
AQB using the ﬁrst q eigenvectors.
Then, our sought after axes U = [u1, ..., uq] is simply R−1
A ˆU and likewise
and the axes V = [v1, ..., vq] is equal to R−1
B ˆV . The axes are called ”canon-
ical vectors”, and the vectors gi = Aui (mutually orthogonal) are called
”variates”. The concept of principal angles is due to Jordan in 1875, where
Hotelling in 1936 is the ﬁrst to introduce the recursive deﬁnition above.
Given a new vector x ∈Rk the resulting vector y can be found by solving
the linear system U⊤x = V ⊤y (since our assumption is that in the new basis
the coordinates of x and y are similar).
To conclude, the relationship between A and B is captured by creating
similar variates, i.e., creating subspaces of dimension q such that the projec-
tions of the input vectors and the output vectors have similar coordinates.
5.9 Canonical Correlation Analysis
57
The process for obtaining the two q-dimensional subspaces is by performing
a QR factorization of A and B followed by an SVD. Here again the spectral
analysis of the input and output data matrices plays a pivoting role in the
input/output association.
6
Spectral Analysis II: Clustering
In the previous lecture we ended up with the formulation:
max
Gm×k trace(G⊤KG)
s.t. G⊤G = I
(6.1)
and showed the solution G is the leading eigenvectors of the symmetric pos-
itive semi deﬁnite matrix K. When K = AA⊤(sample covariance matrix)
with A = [x1, ..., xm], xi ∈Rn, those eigenvectors form a basis to a k-
dimensional subspace of Rn which is the closest (in L2 norm sense) to the
sample points xi. The axes (called principal axes) g1, ..., gk preserve the
variance of the original data in the sense that the projection of the data
points on the g1 has maximum variance, projection on g2 has the maximum
variance over all vectors orthogonal to g1, etc. The spectral decomposition
of the sample covariance matrix is a way to ”compress” the data by means
of linear super-position of the original coordinates y = G⊤x.
We also ended with a ratio formulation:
max
w
w⊤S1w
w⊤S2w
where S1, S2 where scatter matrices deﬁned such that w⊤S1w is the variance
of class centers (which we wish to maximize) and w⊤S2w is the sum of
within class variance (which we want to minimize). The solution w is the
generalized eigenvector S1w = λS2w with maximal λ.
In this lecture we will show additional applications where the search for
leading eigenvectors plays a pivotal part of the solution. So far we have
seen how spectral analysis relates to PCA and LDA and today we will fo-
cus on the classic Data Clustering problem of partitioning a set of points
x1, ..., xm into k ≥2 classes, i.e., generating as output indicator variables
y1, ..., ym where yi ∈{1, ..., k}. We will begin with ”K-means” algorithm for
clustering and then move on to show how the optimization criteria relates
58
6.1 K-means Algorithm for Clustering
59
to grapth-theoretic approaches (like Min-Cut, Ratio-Cut, Normalized Cuts)
and spectral decomposition.
6.1 K-means Algorithm for Clustering
The K-means formulation (originally introduced by [4]) assumes that the
clusters are deﬁned by the distance of the points to their class centers only.
In other words, the goal of clustering is to ﬁnd those k mean vectors c1, ..., ck
and provide the cluster assignment yi ∈{1, ..., k} of each point xi in the set.
The K-means algorithm is based on an interleaving approach where the
cluster assignments yi are established given the centers and the centers are
computed given the assignments. The optimization criterion is as follows:
min
y1,...,ym,c1,...,ck
k
X
j=1
X
yi=j
∥xi −cj∥2
(6.2)
Assume that c1, ..., ck are given from the previous iteration, then
yi = argmin
j
∥xi −cj∥2,
and next assume that y1, .., ym (cluster assignments) are given, then for any
set S ⊆{1, ..., m} we have that
1
|S|
X
j∈S
xj = argmin
c
X
j∈S
∥xj −c∥2.
In other words, given the estimated centers in the current round, the new
assignments are computed by the closest center to each point xi, and then
given the updated assignments the new centers are estimated by taking the
mean of each cluster. Since each step is guaranteed to reduce the optimiza-
tion energy the process must converge — to some local optimum.
The drawback of the K-means algorithm is that the quality of the local
optimum strongly depends on the initial guess (either the centers or the
assignments). If we start with a wild guess for the centers it would be fairly
unlikely that the process would converge to a good local minimum (i.e. one
that is close to the global optimum). An alternative approach would be to
deﬁne an approximate but simpler problem which has a closed form solution
(such as obtained by computing eigenvectors of some matrix). The global
optimum of the K-means is an NP-Complete problem (mentioned brieﬂy in
the next section).
Next, we will rewrite the K-means optimization criterion in matrix form
and see that it relates to the spectral formulation (eqn. 6.1).
60
Spectral Analysis II: Clustering
6.1.1 Matrix Formulation of K-means
We rewrite eqn. 6.2 as follows [7]. Instead of carrying the class variables yi
we deﬁne class sets ψ1, ..., ψk where ψi ⊂{1, ..., n} with S ψj = {1, ..., n}
and ψi
T ψj = ∅. The K-means optimization criterion seeks for the centers
and the class sets:
min
ψ1,...,ψk,c1,...,ck
k
X
j=1
X
i∈ψj
∥xi −cj∥2.
Let lj = |ψj| and following the expansion of the squared norm and dropping
x⊤
i xi we end up with an equivalent problem:
min
ψ1,...,ψk,c1,...,ck
k
X
j=1
ljc⊤
j cj −2
k
X
j=1
X
i∈ψj
x⊤
i cj.
Next we substitute cj with its deﬁnition: (1/lj) P
i∈ψj xj and obtain a new
equivalent formulation where the centers cj are eliminated form considera-
tion:
min
ψ1,...,ψk
−
k
X
j=1
1
lj
X
r,s∈ψj
x⊤
r xs
which is more conveniently written as a maximization problem:
max
ψ1,...,ψk
k
X
j=1
1
lj
X
r,s∈ψj
x⊤
r xs.
(6.3)
Since the resulting formulation involves only inner-products we could have
replaced xi with φ(xi) in eqn. 6.2 where the mapping φ(·) is chosen such
that φ(xi)⊤φ(xj) can be replaced by some non-linear function κ(xi, xj) —
known as the ”kernel trick” (discussed in previous lectures). Having the
ability to map the input vectors onto some high-dimensional space before
K-means is applied provides more ﬂexibility and increases our chances of
getting out a ”good” clustering from the global K-means solution (again,
the local optimum depends on the initial conditions so it could be ”bad”).
The RBF kernel is quite popular in this context κ(xi, xj) = e−∥xi−xj∥2/σ2
with σ some pre-determined parameter. Note that κ(xi, xj) ∈(0, 1] which
can be interpreted loosely as the probability of xi and xj to be clustered
together.
Let Kij = κ(xi, xj) making K a m × m symmetric positive-semi-deﬁnite
matrix often referred to as the ”aﬃnity” matrix. Let F be an n × n matrix
whose entries are Fij = 1/lr if (i, j) ∈ψr for some class ψr and Fij = 0
6.1 K-means Algorithm for Clustering
61
otherwise.
In other words, if we sort the points xi according to cluster
membership, then F is a block diagonal matrix with blocks F1, ..., Fk where
Fr = (1/lr)11⊤is an lr × lr block of 1’s scaled by 1/lr. Then, Eqn. 6.3 can
be written in terms of K as follows:
max
F
n
X
i,j=1
KijFij = trace(KF)
(6.4)
In order to form this as an optimization problem we need to represent the
structure of F in terms of constraints. Let G be an n × k column-scaled
indicator matrix: Gij = (1/
p
lj) if i ∈ψj (i.e., xi belongs to the j’th class)
and Gij = 0 otherwise. Let g1, ..., gk be the columns of G and it can be easily
veriﬁed that grgr
⊤= diag(0, .., Fr, 0, .., 0) therefore F = P
j gjg⊤
j = GG⊤.
Since trace(AB) = trace(BA) we can now write eqn. 6.4 in terms of G:
max
G trace(G⊤KG)
under conditions on G which we need to further spell out.
We will start with the necessary conditions. Clearly G ≥0 (has non-
negative entries). Because each point belongs to exactly one cluster we must
have G⊤Gij = 0 when i ̸= j and G⊤Gii = (1/li)1⊤1 = 1, thus G⊤G = I.
Furthermore we have that the rows and columns of F = GG⊤sum up to
1, i.e., F1 = 1, F ⊤1 = 1 which means that F is doubly stochastic which
translates to the constraint GG⊤1 = 1 on G.
We have therefore three
necessary conditions on G: (i) G ≥0, (ii) G⊤G = I, and (iii) GG⊤1 = 1.
The claim below asserts that these are also suﬃcient conditions:
Claim 4 The feasibility set of matrices G which satisfy the three conditions
G ≥0, GG⊤1 = 1 and G⊤G = I are of the form:
Gij =
(
1
√
lj
xi ∈ψj
0
otherwise
)
Proof:
From G ≥0 and g⊤
r gs = 0 we have that GirGis = 0, i.e., G
has a single non-vanishing element in each row. It will be convenient to
assume that the points are sorted according to the class membership, thus
the columns of G have the non-vanishing entries in consecutive order and
let lj be the number of non-vanishing entries in column gj.
Let uj the
vector of lj entries holding only the non-vanishing entries of gj.
Then,
the doubly stochastic constraint GG⊤1 = 1 results that (1⊤uj)uj = 1 for
j = 1, ..., k.
Multiplying 1 from both sides yields (1⊤uj)2 = 1⊤1 = lj,
therefore uj = (1/
p
lj)1.
62
Spectral Analysis II: Clustering
This completes the equivalence between the matrix formulation:
max
G∈Rm×k trace(G⊤KG)
s.t. G ≥0, G⊤G = I, GG⊤1 = 1
(6.5)
and the original K-means formulation of eqn. 6.2.
We have obtained the same optimization criteria as eqn. 6.1 with addi-
tional two constraints: G should be non-negative and GG⊤should be doubly
stochastic. The constraint G⊤G = I comes from the requirement that each
point is assigned to one class only. The doubly stochastic constraint comes
from a ”class balancing” requirement which we will expand on below.
6.2 Min-Cut
We will arrive to eqn. 6.5 from a graph-theoretic perspective.
We start
with representing the graph Min-Cut problem in matrix form, as follows.
A convenient way to represent the data to be clustered is by an undirected
graph with edge-weights where V = {1, ..., m} is the vertex set, E ⊂V × V
is the edge set and κ : E →R+ is the positive weight function. Vertices
of the graph correspond to data points xi, edges represent neighborhood
relationships, and edge-weights represent the similarity (aﬃnity) between
pairs of linked vertices. The weight adjacency matrix K holds the weights
where Kij = κ(i, j) for (i, j) ∈E and Kij = 0 otherwise.
A cut in the graph is deﬁned between two disjoint sets A, B ⊂V , A ∪
B = V , is the sum of edge-weights connecting the two sets: cut(A, B) =
P
i∈A,j∈B Kij which is a measure of dissimilarity between the two sets. The
Min-Cut problem is to ﬁnd a minimal weight cut in the graph (can be solved
in polynomial time through Max Network Flow solution). The following
claim associates algebraic conditions on G with an indicator matrix:
Claim 5 The feasibility set of matrices G which satisfy the three conditions
G ≥0, G1 = 1 and G⊤G = D for some diagonal matrix D are of the form:
Gij =
 1
xi ∈ψj
0
otherwise

Proof:
Let G = [g1, ..., gk]. From G ≥0 and g⊤
r gs = 0 we have that
GirGis = 0, i.e., G has a single non-vanishing element in each row. From
G1 = 1 the single non-vanishing entry of each row must have the value of
1.
In the case of two classes (k = 2), the function tr(G⊤KG) is equal to
P
(i,j)∈ψ1 Kij + P
(i,j)∈ψ2 Kij. Therefore maxG tr(G⊤KG) is equivalent to
6.3 Spectral Clustering: Ratio-Cuts and Normalized-Cuts
63
minimizing the cut: P
i∈ψ1,j∈ψ2 Kij. As a result, the Min-Cut problem is
equivalent to solving the optimization problem:
max
G∈Rm×2 tr(G⊤KG) s.t
G ≥0, G1 = 1, G⊤G = diag
(6.6)
We seem to be close to eqn. 6.5 with the diﬀerence that G is orthogonal
(instead of orthonormal) and the doubly-stochasitc constraint is replaced
by G1 = 1. The diﬀerence can be bridged by considering a ”balancing”
requirement. Min-Cut can produce an unbalanced partition where one set
of vertices is very large and the other contains a spurious set of vertices
having a small number of edges to the larger set. This is an undesirable
outcome in the context of clustering.
Consider a ”balancing” constraint
G⊤1 = (m/k)1 which makes a strict requirement that all the k clusters have
an equal number of points. We can relax the balancing constraint slightly by
combining the balancing constraint with G1 = 1 into one single constraint
GG⊤1 = (m/k)1, i.e., GG⊤is scaled doubly stochastic. Note that the two
conditions GG⊤1 = (m/k)1 and G⊤G = D result in D = (m/k)I. Thus we
propose the relaxed-balanced hard clustering scheme:
max
G tr(G⊤KG) s.t
G ≥0, GG⊤1 = m
k 1, G⊤G = m
k I
The scale m/k is a global scale that can be dropped without aﬀecting the
resulting solution, thus the Min-Cut with a relaxed balancing requirement
becomes eqn. 6.5 which we saw is equivalent to K-means:
max
G tr(G⊤KG) s.t
G ≥0, GG⊤1 = 1, G⊤G = I.
6.3 Spectral Clustering: Ratio-Cuts and Normalized-Cuts
We saw above that the doubly-stochastic constraint has to do with a ”bal-
ancing” desire. A further relaxation of the balancing desire is to perform the
optimization in two steps: (i) replace the aﬃnity matrix K with the closest
(under some chosen error measure) doubly-stochastic matrix K′, (ii) ﬁnd a
solution to the problem:
max
G∈Rm×k tr(G⊤K′G) s.t
G ≥0, G⊤G = I
(6.7)
because GG⊤should come out close to K′ (tr(G⊤K′G) = tr(K′GG⊤))
and K′ is doubly-stochastic, then GG⊤should come out close to satisfying
a doubly-stochastic constraint — this is the motivation behind the 2-step
approach. Moreover, we drop the non-negativity constraint G ≥0. Note
that the non-negativity constraint is crucial for the physical interpretation of
64
Spectral Analysis II: Clustering
G; nevertheless, for k = 2 clusters it is possible to make an interpretation, as
we shall next. As a result we are left with a spectral decomposition problem
of eqn. 6.1:
max
G∈Rm×k tr(G⊤K′G) s.t
G⊤G = I,
where the columns of G are the leading eigenvectors of K′. We will refer
to the ﬁrst step as a ”normalization” process and there are two popular
normalizations in the literature — one leading to Ratio-Cuts and the other
to Normalized-Cuts.
6.3.1 Ratio-Cuts
Let D = diag(K1) which is a diagonal matrix containing the row sums of
K. The Ratio-Cuts normalization is to look for K′ as the closest doubly-
stochastic matrix to K by minimizing the L1 norm — this turns out to be
K′ = K −D + I.
Claim 6 (ratio-cut) Let K be a symmetric positive-semi-deﬁnite whose
values are in the range [0, 1]. The closest doubly stochastic matrix K′ under
the L1 error norm is
K′ = K −D + I
Proof: Let r = minF ∥K −F∥1 s.t. F1 = 1, F = F ⊤. Since ∥K −F∥1 ≥
∥(K −F)1∥1 for any matrix F, we must have:
r ≥∥(K −F)1∥1 = ∥D1 −1∥1 = ∥D −I∥1.
Let F = K −D + I, then
∥K −(K −D + I)∥1 = ∥D −I∥1.
The Laplacian matrix of a graph is D −K. If v is an eigenvector of the
Laplacian D −K with eigenvalue λ, then v is also an eigenvector of K′ =
K −D + I with eigenvalue 1 −λ and since (D −K)1 = 0 then the smallest
eigenvector v = 1 of the Laplacian is the largest of K′, and the second
smallest eigenvector of the Laplacian (the ratio-cut result) corresponds to the
second largest eigenvector of K′. Because the eigenvectors are orthogonal,
the second eigenvector must have positive and negative entries (because the
inner-product with 1 is zero) — thus the sign of the entries of the second
eigenvector determines the class membership.
6.3 Spectral Clustering: Ratio-Cuts and Normalized-Cuts
65
Ratio-Cuts, the second smallest eigenvector of the Laplacian D −K, is
an approximation due to Hall in the 70s [2] to the Min-Cut formulation.
Let z ∈Rm determine the class membership such that xi and xj would be
clustered together if zi and zj have similar values. This leads to the following
optimization problem:
min
z
1
2
X
i,j
(zi −zj)2Kij
s.t.
z⊤z = 1
The criterion function is equal to (1/2)z⊤(D−K)z and the derivative of the
Lagrangian (1/2)z⊤(D −K)z −λ(z⊤z −1) with respect to z gives rise to
the necessary condition (D −K)z = λz and the Ratio-Cut scheme follows.
6.3.2 Normalized-Cuts
Normalized-Cuts looks for the closest doubly-stochastic matrix K′ in relative
entropy error measure deﬁned as:
RE(x || y) =
X
i
xi ln xi
yi
+
X
i
yi −
X
i
xi.
We will encounter the relative entropy measure in more detail later in the
course. We can show that K′ must have the form ΛKΛ for some diagonal
matrix Λ:
Claim 7 The closest doubly-stochastic matrix F under the relative-entropy
error measure to a given non-negative symmetric matrix K, i.e., which min-
imizes:
min
F
RE(F||K) s.t. F ≥0, F = F ⊤, F1 = 1, F ⊤1 = 1
has the form F = ΛKΛ for some (unique) diagonal matrix Λ.
Proof: The Lagrangian of the problem is:
L() =
X
ij
fij ln fij
kij
+
X
ij
kij −
X
ij
fij −
X
i
λi(
X
j
fij −1)−
X
j
µj(
X
i
fij −1)
The derivative with respect to fij is:
∂L
∂fij
= ln fij + 1 −ln kij −1 −λi −µj = 0
from which we obtain:
fij = eλieµjkij
66
Spectral Analysis II: Clustering
Let D1 = diag(eλ1, ..., eλn) and D2 = diag(eµ1, ..., eµn), then we have:
F = D1KD2
Since F = F ⊤and K is symmetric we must have D1 = D2.
Next, we can show that the diagonal matrix Λ can found by an iterative
process where K is replaced by D−1/2KD−1/2 where D was deﬁned above
as diag(K1):
Claim 8 For any non-negative symmetric matrix K(0), iterating the process
K(t+1) ←D−1/2K(t)D−1/2 with D = diag(K(t)1) converges to a doubly
stochastic matrix.
The proof is based on showing that the permanent increases monotonically,
i.e. perm(K(t+1)) ≥perm(K(t)). Because the permanent is bounded the
process must converge and if the permanent does not change (at the conver-
gence point) the resulting matrix must be doubly stochastic. The resulting
doubly stochastic matrix is the closest to K in relative-entropy.
Normalized-Cuts takes the result of the ﬁrst iteration by replacing K
with K′ = D−1/2KD−1/2 followed by the spectral decomposition (in case
of k = 2 classes the partitioning information is found in the second leading
eigenvector of K′ — just like Ratio-Cuts but with a diﬀerent K′). Thus, K′
in this manner is not the closest doubly-stochastic matrix to K but is fairly
close (the ﬁrst iteration is the dominant one in the process).
Normalized-Cuts, as the second leading eigenvector of K′ = D−1/2KD−1/2,
is an approximation to a ”balanced” Min-Cut described ﬁrst in [6]. Deriving
it from ﬁrst principles proceeds as follows:
Let sum(V1, V2) = sumi∈V1,j∈V2Kij be deﬁned for any two subsets (not
necessarily disjoint) of vertices. The normalized-cuts measures the cut cost
as a fraction of the total edge connections to all the nodes in the graph:
Ncuts(A, B) = cut(A, B)
sum(A, V ) + cut(A, B)
sum(B, V ).
A minimal Ncut partition will no longer favor small isolated points since the
cut value would most likely be a large percentage of the total connections
from that small set to all the other vertices. A related measure Nassoc(A, B)
deﬁned as:
Nassoc(A, B) = sum(A, A)
sum(A, V ) + sum(B, B)
sum(B, V ),
reﬂects how tightly on average nodes within the group are connected to each
other. Given that cut(A, B) = sum(A, V )−sum(A, A) one can easily verify
6.3 Spectral Clustering: Ratio-Cuts and Normalized-Cuts
67
that:
Ncuts(A, B) = 2 −Nassoc(A, B),
therefore the optimal bi-partition can be represented as maximizing Nassoc(A, V −
A). The Nassoc naturally extends to k > 2 classes (partitions) as follows:
Let ψ1, ..., ψk be disjoint sets ∪jψj = V , then:
Nassoc(ψ1, ..., ψk) =
k
X
j=1
sum(ψj, ψj)
sum(ψj, V ) .
We will now rewrite Nassoc in matrix form and establish equivalence to
eqn. 6.7. Let ¯G = [g1, ..., gk] with gj = 1/
p
sum(ψj, V )(0, ..., 0, 1, ...1, 0., , , 0)
with the 1s indicating membership to the j’th class. Note that
g⊤
j Kgj = sum(ψj, ψj)
sum(ψj, V ) ,
therefore trace( ¯G⊤K ¯G) = Nassoc(ψ1, ..., ψk).
Note also that g⊤
i Dgi =
(1/sum(ψi, V )) P
r∈ψi dr = 1, therefore ¯G⊤D ¯G = I. Let G = D1/2 ¯G so we
have that G⊤G = I and trace(G⊤D−1/2KD−1/2G) = Nassoc(ψ1, ..., ψk).
Taken together we have that maximizing Nassoc is equivalent to:
max
G∈Rm×k trace(G⊤K′G)
s.t. G ≥0, G⊤G = I,
(6.8)
where K′ = D−1/2KD−1/2. Note that this is exactly the K-means matrix
setup of eqn. 6.5 where the doubly-stochastic constraint is relaxed into the
replacement of K by K′. The constraint G ≥0 is then dropped and the
resulting solution for G is the k leading eigenvectors of K′.
We have arrived via seemingly diﬀerent paths to eqn. 6.8 which after we
drop the constraint G ≥0 we end up with a closed form solution consisting
of the k leading eigenvectors of K′.
When k = 2 (two classes) one can
easily verify that the partitioning information is fully contained in the second
eigenvector.
Let v1, v2 be the ﬁrst leading eigenvectors of K′.
Clearly
v = D1/21 is an eigenvector with eigenvalue λ = 1:
D−1/2KD−1/2(D1/21) = D−1/2K1 = D1/21.
In fact λ = 1 is the largest eigenvalue (left as an exercise) thus v1 = D1/21 >
0.
Since K′ is symmetric the v⊤
2 v1 = 0 thus v2 contains positive and
negative entries — those are interpreted as indicating class membership
(positive to one class and negative to the other).
The case k > 2 is treated as an embedding (also known as Multi-Dimensional
Scaling) by re-coordinating the points xi using the rows of G.
In other
68
Spectral Analysis II: Clustering
words, the i’th row of G is a representation of xi in Rk. Under ideal con-
ditions where K is block diagonal (the distance between clusters is inﬁnity)
the rows associated with points clustered together are identical (i.e., the n
original points are mapped to k points in Rk) [5]. In practice, one performs
the iterative K-means in the embedded space.
7
The Formal (PAC) Learning Model
We have see so far algorithms that explicitly estimate the underlying dis-
tribution of the data (Bayesian methods and EM) and algorithms that are
in some sense optimal when the underlying distribution is Gaussian (PCA,
LDA). We have also encountered an algorithm (SVM) that made no as-
sumptions on the underlying distribution and instead tied the accuracy to
the margin of the training data.
In this lecture and in the remainder of the course we will address the
issue of ”accuracy” and ”generalization” in a more formal manner. Because
the learner receives only a ﬁnite training sample, the learning function can
do very well on the training set yet perform badly on new input instances.
What we would like to establish are certain guarantees on the accuracy of
the learner measured over all the instance space and not only on the training
set. We will then use those guarantees to better understand what the large-
margin principle of SVM is doing in the context of generalization.
In the remainder of this lecture we will refer to the following notations:
the class of learning functions is denoted by C. A learning functions is often
referred to as a ”concept” or ”hypothesis”. A target function ct ∈C is a
function that has zero error on all input instances (such a function may not
always exist).
7.1 The Formal Model
In many learning situations of interest, we would like to assume that the
learner receives m examples sampled by some ﬁxed (yet unknown) distri-
bution D and the learner must do its best with the training set in order to
achieve the accuracy and conﬁdence objectives. The Probably Approximate
Correct (PAC) model, also known as the ”formal model”, ﬁrst introduced by
69
70
The Formal (PAC) Learning Model
Valient in 1984, provides a probabilistic setting which formalizes the notions
of accuracy and conﬁdence.
The PAC model makes the following statistical assumption. We assume
the learner receives a set S of m instances x1, ..., xm ∈X which are sampled
randomly and independently according to a distribution D over X. In other
words, a random training set S of length m is distributed according to the
product probability distribution Dm. The distribution D is unknown, but
we will see that one can obtain useful results by simply assuming that D is
ﬁxed — there is no need to attempt to recover D during the learning process.
To recap, we make the following three assumptions: (i) D is unkown, (ii)
D is ﬁxed throughout the learning process, and (iii) the example instances
are sampled independently of each other (are Identically and Independently
Distributed — i.i.d.).
We distinguish between the ”realizable” case where a target concept ct(x)
is known to exist, and the unrealizable case, where there is no such guar-
antee. In the realizable case our training examples are Z = {(xi, ct(xi)},
i = 1, ..., m and D is deﬁned over X (since yi ∈Y are given by ct(xi)). In
the unrealizable case, Z = {(xi, yi)} and D is the distribution over X × Y
(each element is a pair, one from X and the other from Y ).
We next deﬁne what is meant by the error induced by a concept function
h(x). In the realizable case, given a function h ∈C, the error of h is deﬁned
with respect to the distribution D:
err(h) = probD[x : ct(x) ̸= h(x)] =
Z
x∈X
ind(ct(x) ̸= h(x))D(x)dx
where ind(F) is an indication function which returns ’1’ if the proposition
F is true and ’0’ otherwise.
The function err(h) is the probability that
an instance x sampled according to D will be labeled incorrectly by h(x).
Let ϵ > 0 be a parameter given to the learner specifying the ”accuracy” of
the learning process, i.e. we would like to achieve err(h) ≤ϵ. Note that
err(ct) = 0.
In addition, we deﬁne a ”conﬁdence” parameter δ > 0, also given to the
learner, which deﬁnes the probability that err(h) > ϵ, namely,
prob[err(h) > ϵ] < δ,
or equivalently:
prob[err(h) ≤ϵ] ≥1 −δ.
In other words, the learner is supposed to meet some accuracy criteria but
is allowed to deviate from it by some small probability. Finally, the learning
7.1 The Formal Model
71
algorithm is supposed to be ”eﬃcient” if the running time is polynomial in
1/ϵ, ln(1/δ), n and the size of the concept target function ct() (measured by
the number of bits necessary for describing it, for example).
We will say that an algorithm L learns a concept family C in the formal
sense (PAC learnable) if for any ct ∈C and for every distribution D on the
instance space X, the algorithm L generates eﬃciently a concept function
h ∈C such that the probability that err(h) ≤ϵ is at least 1 −δ.
The inclusion of the conﬁdence value δ could seem at ﬁrst unnatural.
What we desire from the learner is to demonstrate a consistent performance
regardless of the training sample Z. In other words, it is not enough that
the learner produces a hypothesis h whose accuracy is above threshold, i.e.,
err(h) ≤ϵ, for some training sample Z. We would like the accuracy per-
formance to hold under all training samples (sampled from the distribution
Dm) — since this requirement could be too diﬃcult to satisfy, the formal
model allows for some ”failures”, i.e, situations where err(h) > ϵ, for some
training samples Z, as long as those failures are rare and the frequency of
their occurrence is controlled (the parameter δ) and can be as small as we
like.
In the unrealizable case, there may be no function h ∈C for which
err(h) = 0, thus we need to deﬁne what we mean by the best a learning
algorithm can achieve:
Opt(C) = min
h∈C err(h),
which is the best that can be done on the concept class C using functions
that map between X and Y . Given the desired accuracy ϵ and conﬁdence δ
values the learner seeks a hypothesis h ∈C such that:
prob[err(h) ≤Opt(C) + ϵ] ≥1 −δ.
We are ready now to formalize the discussion above and introduce the deﬁ-
nition of the formal learning model (Anthony & Bartlett [1], pp. 16):
Deﬁnition 1 (Formal Model) Let C be the concept class of functions that
map from a set X to Y . A learning algorithm L is a function:
L :
∞
[
m=1
{(xi, yi)}m
i=1 →C
from the set of all training examples to C with the following property: given
any ϵ, δ ∈(0, 1) there is an integer m0(ϵ, δ) such that if m ≥m0 then, for
any probability distribution D on X × Y , if Z is a training set of length m
72
The Formal (PAC) Learning Model
drawn randomly according to the product probability distribution Dm, then
with probability of at least 1 −δ the hypothesis h = L(Z) ∈C output by
L is such that err(h) ≤Opt(C) + ϵ. We say that C is learnable (or PAC
learnable) if there is a learning algorithm for C.
There are few points to emphasize. The sample size m0(ϵ, δ) is a suf-
ﬁcient sample size for PAC learning C by L and is allowed to vary with
ϵ, δ. Decreasing the value of either ϵ or δ makes the learning problem more
diﬃcult and in turn a larger sample size is required. Note however that
m0(ϵ, δ) does not depend on the distribution D! that is, a suﬃcient sample
size can be given that will work for any distribution D — provided that
D is ﬁxed throughout the learning experience (both training and later for
testing). This point is a crucial property of the formal model because if the
suﬃcient sample size is allowed to vary with the distribution D then not
only we would need to have some information about the distribution in or-
der to set the sample complexity bounds, but also an adversary (supplying
the training set) could control the rate of convergence of L to a solution
(even if that solution can be proven to be optimal) and make it arbitrarily
slow by suitable choice of D.
What makes the formal model work in a distribution-invariant manner
is that it critically depends on the fact that in many interesting learning
scenarios the concept class C is not too complex. For example, we will show
later in the lecture that any ﬁnite concept class |C| < ∞is learnable, and
the sample complexity (in the realizable case) is
m ≥1
ϵ ln |C|
δ .
In the next lecture we will consider concept classes of inﬁnite size and show
that despite the fact that the class is inﬁnite it still can be of low complexity!
Before we illustrate the concepts above with an example, there is another
useful measure which is the empirical error (also known as the sample error)
ˆ
err(h) which is deﬁned as the proportion of examples from Z on which h
made a mistake:
ˆ
err(h) = 1
m|{i : h(xi) ̸= ct(xi)}|
(replace ct(xi) with yi for the unrealizable case). The situation of bounding
the true error err(h) by minimizing the sample error
ˆ
err(h) is very conve-
nient — we will get to that later.
7.2 The Rectangle Learning Problem
73
7.2 The Rectangle Learning Problem
As an illustration of learnability we will consider the problem (introduced
in Kearns & Vazirani [3]) of learning an axes-aligned rectangle from positive
and negative examples. We will show that the problem is PAC-learnable
and ﬁnd out m0(ϵ, δ).
In the rectangle learning game we are given a training set consisting of
points in the 2D plane with a positive ’+’ or negative ’-’ label. The positive
examples are sampled inside the target rectangle (parallel to the main axes)
R and the negative examples are sampled outside of R. Given m examples
sampled i.i.d according to some distribution D the learner is supposed to
generate an approximate rectangle R′ which is consistent with the training
set (we are assuming that R exists) and which satisﬁes the accuracy and
conﬁdence constraints.
We ﬁrst need to decide on a learning strategy.
Since the solution R′
is not uniquely deﬁned given any training set Z, we need to add further
constraints to guarantee a unique solution. We will choose R′ as the axes-
aligned concept which gives the tightest ﬁt to the positive examples, i.e., the
smallest area axes-aligned rectangle which contains the positive examples.
If no positive examples are given then R′ = ∅. We can also assume that
Z contains at least three non-collinear positive examples in order to avoid
complications associated with inﬁnitesimal area rectangles. Note that we
could have chosen other strategies, such as the middle ground between the
tightest ﬁt to the positive examples and the tightest ﬁt (from below) to the
negative examples, and so forth. Deﬁning a strategy is necessary for the
analysis below — the type of strategy is not critical though.
We next deﬁne the error err(R′) on the concept R′ generated by our
learning strategy. We ﬁrst note that with the strategy deﬁned above we
always have R′ ⊂R since R′ is the tightest ﬁt solution which is consistent
with the sample data (there could be a positive example outside of R′ which
is not in the training set). We will deﬁne the ”weight” w(E) of a region E
in the plane as
w(E) =
Z
x∈E
D(x)dx,
i.e., the probability that a random point sampled according to the distri-
bution D will fall into the region. Therefore, the error associated with the
concept R′ is
err(R′) = w(R −R′)
74
The Formal (PAC) Learning Model
Fig. 7.1. Given the tightest-ﬁt to positive examples strategy we have that R′ ⊂R.
The strip T1 has weight ϵ/4 and the strip T ′
1 is deﬁned as the upper strip covering
the area between R and R′.
and we wish to bound the error w(R −R′) ≤ϵ with probability of at least
1 −δ after seeing m examples.
We will divide the region R −R′ into four strips T ′
1, ..., T ′
4 (see Fig.7.1)
which overlap at the corners. We will estimate prob(w(T ′
i) ≥ϵ
4) noting that
the overlaps between the regions makes our estimates more pessimistic than
they truly are (since we are counting the overlapping regions twice) thus
making us lean towards the conservative side in our estimations.
Consider the upper strip T ′
1. If w(T ′
1 ≤
ϵ
4) then we are done. We are
however interested in quantifying the probability that this is not the case.
Assume w(T ′
1) > ϵ
4 and deﬁne a strip T1 which starts from the upper axis
of R and stretches to the extent such that w(T1) = ϵ
4. Clearly T1 ⊂T ′
1. We
have that w(T ′
1) > ϵ
4 iﬀT1 ⊂T ′
1. Furthermore:
Claim 9 T1 ⊂T ′
1 iﬀx1, ..., xm ̸∈T1.
Proof:
If xi ∈T1 the the label must be positive since T1 ⊂R. But if
the label is positive then given our learning strategy of ﬁtting the tightest
rectangle over the positive examples, then xi ∈R′. Since T1 ̸⊂R′ it follows
that xi ̸∈T1.
We have therefore that w(T ′
1 > ϵ
4) iﬀno point in T1 appears in the sample
S = {x1, ..., xm} (otherwise T1 intersects with R′ and thus T ′
1 ⊂T1). The
probability that a point sampled according to the distribution D will fall
outside of T1 is 1 −ϵ
4. Given the independence assumption (examples are
7.3 Learnability of Finite Concept Classes
75
drawn i.i.d.), we have:
prob(x1, ..., xm ̸∈T1) = prob(w(T ′
1 > ϵ
4)) = (1 −ϵ
4)m.
Repeating the same analysis to regions T ′
2, T ′
3, T ′
4 and using the union bound
P(A ∪B) ≤P(A) + P(B) we come to the conclusion that the probability
that any of the four strips of R −R′ has weight greater that ϵ/4 is at most
4(1 −ϵ
4)m. In other words,
prob(err(L′) ≥ϵ) ≤4((1 −ϵ
4)m ≤δ.
We can make the expression more convenient for manipulation by using the
inequality e−x ≥1 −x (recall that 1 + (1/n))n < e from which it follows
that (1 + z)1/z < e and by taking the power of rz where r ≥0 we obtain
(1 + z)r < erz then set r = 1, z = −x):
4(1 −ϵ
4)m ≤4e−ϵm
4 ≤δ,
from which we obtain the bound:
m ≥4
ϵ ln 4
δ .
To conclude, assuming that the learner adopts the tightest-ﬁt to positive ex-
amples strategy and is given at least m0 = 4
ϵ ln 4
δ training examples in order
to ﬁnd the axes-aligned rectangle R′, we can assert that with probability
1 −δ the error associated with R′ (i.e., the probability that an (m + 1)’th
point will be classiﬁed incorrectly) is at most ϵ.
We can see form the analysis above that indeed it applies to any distri-
bution D where the only assumption we had to make is the independence
of the draw. Also, the sample size m behaves well in the sense that if one
desires a higher level of accuracy (smaller ϵ) or a higher level of conﬁdence
(smaller δ) then the sample size grows accordingly.
The growth of m is
linear in 1/ϵ and linear in ln(1/δ).
7.3 Learnability of Finite Concept Classes
In the previous section we illustrated the concept of learnability with a
particular simple example. We will now focus on applying the learnability
model to a more general family of learning examples. We will consider the
family of all learning problems over ﬁnite concept classes |C| < ∞. For
example, the conjunction learning problem (over boolean formulas) with n
literals contains only 3n hypotheses because each variable can appear in
the conjunction or not and if appears it could be negated or not. We have
76
The Formal (PAC) Learning Model
shown that n is the lower bound on the number of mistakes on the worst
case analysis any on-line algorithm can achieve. With the deﬁnitions we
have above on the formal model of learnability we can perform accuracy
and sample complexity analysis that will apply to any learning problem
over ﬁnite concept classes. This was ﬁrst introduced by Valiant in 1984.
In the realizable case over |C| < ∞, we will show that any algorithm L
which returns a hypothesis h ∈C which is consistent with the training set
Z is a learning algorithm for C. In other words, any ﬁnite concept class
is learnable and the learning algorithms simply need to generate consistent
hypotheses. The sample complexity m0 associated with the choice of ϵ and
δ can be shown as equal to: 1
ϵ ln |C|
δ .
In the unrealizable case, any algorithm L that generates a hypothesis
h ∈C that minimizes the empirical error (the error obtained on Z) is a
learning algorithm for C. The sample complexity can be shown as equal to:
2
ϵ2 ln 2|C|
δ . We will derive these two cases below.
7.3.1 The Realizable Case
Let h ∈C be some consistent hypothesis with the training set Z (we know
that such a hypothesis exists, in particular h = ct the target concept used
for generating Z) and suppose that
err(h) = prob[x ∼D : h(x) ̸= ct(x)] > ϵ.
Then, the probability (with respect to the product distribution Dm) that h
agrees with ct on a random sample of length m is at most (1 −ϵ)m. Using
the inequality we saw before e−x ≥1 −x we have:
prob[err(h) > ϵ && h(xi) = ct(xi),
i = 1, ..., m] ≤(1 −ϵ)m < e−ϵm.
We wish to bound the error uniformly, i.e., that err(h) ≤ϵ for all concepts
h ∈C. This requires the evaluation of:
prob[max
h∈C {err(h) > ϵ} && h(xi) = ct(xi),
i = 1, ..., m].
There at most |C| such functions h, therefore using the Union-Bound the
probability that some function in C has error larger than ϵ and is consistent
7.3 Learnability of Finite Concept Classes
77
with ct on a random sample of length m is at most |C|e−ϵm:
prob[∃h : err(h) > ϵ && h(xi) = ct(xi),
i = 1, ..., m]
≤
X
h:err(h)>ϵ
prob[h(xi) = ct(xi),
i = 1, ..., m]
≤|h : err(h) > ϵ|e−ϵm
≤|C|e−ϵm
For any positive δ, this probability is less than δ provided:
m ≥1
ϵ ln |C|
δ .
This derivation can be summarized in the following theorem (Anthony &
Bartlett [1], pp. 25):
Theorem 5 Let C be a ﬁnite set of functions from X to Y .
Let L be
an algorithm such that for any m and for any ct ∈C, if Z is a training
sample {(xi, ct(xi))}, i = 1, ..., m, then the hypothesis h = L(Z) satisﬁes
h(xi) = ct(xi). Then L is a learning algorithm for C in the realizable case
with sample complexity
m0 = 1
ϵ ln |C|
δ .
7.3.2 The Unrealizable Case
In the realizable case an algorithm simply needs to generate a consistent
hypothesize to be considered a learning algorithm in the formal sense. In
the unrealizable situation (a target function ct might not exist) an algorithm
which minimizes the empirical error, i.e., an algorithm L generates h = L(Z)
having minimal sample error:
ˆ
err(L(Z)) = min
h∈C ˆ
err(h)
is a learning algorithm for C (assuming ﬁnite |C|). This is a particularly
useful property given that the true errors of the functions in C are un-
known. It seems natural to use the sample errors ˆ
err(h) as estimates to the
performance of L.
The fact that given a large enough sample (training set Z) then the sam-
ple error
ˆ
err(h) becomes close to the true error err(h) is somewhat of a
restatement of the ”law of large numbers” of probability theory. For ex-
ample, if we toss a coin many times then the relative frequency of ’heads’
approaches the true probability of ’head’ at a rate determined by the law of
78
The Formal (PAC) Learning Model
large numbers. We can bound the probability that the diﬀerence between
the empirical error and the true error of some h exceeds ϵ using Hoeﬀding’s
inequality:
Claim 10 Let h be some function from X to Y = {0, 1}. Then
prob[| ˆ
err(h) −err(h)| ≥ϵ] ≤2e(−2ϵ2m),
for any probability distribution D, any ϵ > 0 and any positive integer m.
Proof:
This is a straightforward application of Hoeﬀding’s inequality to
Bernoulli variables. Hoeﬀding’s inequality says: Let X be a set, D a proba-
bility distribution on X, and f1, ..., fm real-valued functions fi : X →[ai, bi]
from X to an interval on the real line (ai < bi). Then,
prob
"
| 1
m
m
X
i=1
fi(xi) −Ex∼D[f(x)]| ≥ϵ
#
≤2e
−
2ϵ2m2
P
i(bi−ai)2
(7.1)
where
Ex∼D[f(x)] = 1
m
m
X
i=1
Z
fi(x)D(x)dx.
In our case fi(xi) = 1 iﬀh(xi) ̸= yi and ai = 0, bi = 1.
Therefore
(1/m) P
i fi(xi) = ˆ
err(h) and err(h) = Ex∼D[f(x)].
The Hoeﬀding bound almost does what we need, but not quite so. What
we have is that for any given hypothesis h ∈C, the empirical error is
close to the true error with high probability.
Recall that our goal is to
minimize err(h) over all possible h ∈C but we can access only
ˆ
err(h). If
we can guarantee that the two are close to each other for every h ∈C, then
minimizing
ˆ
err(h) over all h ∈C will approximately minimize err(h). Put
formally, in order to ensure that L learns the class C, we must show that
prob

max
h∈C | ˆ
err(h) −err(h)| < ϵ

> 1 −δ
In other words, we need to show that the empirical errors converge (at high
probability) to the true errors uniformly over C as m →∞. If that can be
guaranteed, then with (high) probability 1 −δ, for every h ∈C,
err(h) −ϵ < ˆ
err(h) < err(h) + ϵ.
So, since the algorithm L running on training set Z returns h = L(Z) which
minimizes the empirical error, we have:
err(L(Z)) ≤ˆ
err(L(Z)) + ϵ = min
h
ˆ
err(h) + ϵ ≤Opt(C) + 2ϵ,
7.3 Learnability of Finite Concept Classes
79
which is what is needed in order that L learns C. Thus, what is left is to
prove the following claim:
Claim 11
prob

max
h∈C | ˆ
err(h) −err(h)| ≥ϵ

≤2|C|e−2ϵ2m
Proof:
We will use the union bound. Finding the maximum over C is
equivalent to taking the union of all the events:
prob

max
h∈C | ˆ
err(h) −err(h)| ≥ϵ

= prob
" [
h∈C
{Z : | ˆ
err(h) −err(h)| ≥ϵ}
#
,
using the union-bound and Claim 2, we have:
≤
X
h∈C
prob [| ˆ
err(h) −err(h)| ≥ϵ] ≤|C|2e(−2ϵ2m).
Finally, given that 2|C|e−2ϵ2m ≤δ we obtain the sample complexity:
m0 = 2
ϵ2 ln 2|C|
δ
.
This discussion is summarized with the following theorem (Anthony & Bartlett
[1], pp. 21):
Theorem 6 Let C be a ﬁnite set of functions from X to Y = {0, 1}. Let L
be an algorithm such that for any m and for any training set Z = {(xi, yi)},
i = 1, ..., m, then the hypothesis L(Z) satisﬁes:
ˆ
err(L(Z)) = min
h∈C ˆ
err(h).
Then L is a learning algorithm for C with sample complexity m0 = 2
ϵ2 ln 2|C|
δ .
Note that the main diﬀerence with the realizable case (Theorem 1) is the
larger 1/ϵ2 rather than 1/ϵ. The realizable case requires a smaller training
set since we are estimating a random quantity so the smaller the variance
the less data we need.
8
The VC Dimension
The result of the PAC model (also known as the ”formal” learning model)
is that if the concept class C is PAC-learnable then the learning strategy
must simply consist of gathering a suﬃciently large training sample S of
size m > mo(ϵ, δ), for given accuracy ϵ > 0 and conﬁdence 0 < δ < 1
parameters, and ﬁnds a hypothesis h ∈C which is consistent with S. The
learning algorithm is then guaranteed to have a bounded error err(h) < ϵ
with probability 1 −δ. The error measurement includes data not seen by
the training phase.
This state of aﬀair also holds (with some slight modiﬁcations on the sam-
ple complexity bounds) when there is no consistent hypothesis (the unreal-
izable case). In this case the learner simply needs to minimize the empirical
error
ˆ
err(h) on the sample training data S, and if m is suﬃciently large
then the learner is guaranteed to have err(h) < Opt(C)+ϵ with probability
1 −δ. The measure Opt(C) is deﬁned as the minimal err(g) over all g ∈C.
Note that in the realizable case Opt(C) = 0.
The property of bounding the true error err(h) by minimizing the sample
error
ˆ
err(h) is very convenient. The fundamental question is under what
conditions this type of generalization property applies? We saw in the previ-
ous lecture that a satisfactorily answer can be provided when the cardinality
of the concept space is bounded, i.e. |C| < ∞, which happens for Boolean
concept space for example. In that lecture we have proven that:
mo(ϵ, δ) = O(1
ϵ ln |C|
δ ),
is suﬃcient for guaranteeing a learning model in the formal sense, i.e., which
has the generalization property described above.
In this lecture and the one that follows we have two goals in mind. First
is to generalize the result of ﬁnite concept class cardinality to inﬁnite car-
80
8.1 The VC Dimension
81
dinality — note that the bound above is not meaningful when |C| = ∞.
Can we learn in the formal sense any non-trivial inﬁnite concept class? (we
already saw an example of a PAC-learnable inﬁnite concept class which is
the class of axes aligned rectangles). In order to answer this question we will
need to a general measure of concept class complexity which will replace the
cardinality term |C| in the sample complexity bound mo(ϵ, δ). It is tempting
to assume that the number of parameters which fully describe the concepts
of C can serve as such a measure, but we will show that in fact one needs
a more powerful measure called the Vapnik-Chervonenkis (VC) dimension.
Our second goal is to pave the way and provide the theoretical foundation
for the large margin principle algorithm (SVM) we derived in Lecture 4.
8.1 The VC Dimension
The basic principle behind the VC dimension measure is that although C
may have inﬁnite cardinality, the restriction of the application of concepts
in C to a ﬁnite sample S has a ﬁnite outcome. This outcome is typically
governed by an exponential growth with the size m of the sample S — but
not always. The point at which the growth stops being exponential is when
the ”complexity” of the concept class C has exhausted itself, in a manner
of speaking.
We will assume C is a concept class over the instance space X — both
of which can be inﬁnite. We also assume that the concept class maps in-
stances in X to {0, 1}, i.e., the input instances are mapped to ”positive”
or ”negative” labels. A training sample S is drawn i.i.d according to some
ﬁxed but unknown distribution D and S consists of m instances x1, ..., xm.
In our notations we will try to reserve c ∈C to denote the target concept
and h ∈C to denote some concept. We begin with the following deﬁnition:
Deﬁnition 2
ΠC(S) = {(h(x1), ..., h(xm) : h ∈C}
which is a set of vectors in {0, 1}m.
ΠC(S) is set whose members are m-dimensional Boolean vectors induced by
functions of C. These members are often called dichotomies or behaviors on
S induced or realized by C. If C makes a full realization then ΠC(S) will
have 2m members. An equivalent description is a collection of subsets of S:
ΠC(S) = {h ∩S : h ∈C}
where each h ∈C makes a partition of S into two sets — the positive and
82
The VC Dimension
negative points. The set ΠC(S) contains therefore subsets of S (the positive
points of S under h). A full realization will provide Pm
i=0
 m
i

= 2m. We
will use both descriptions of ΠC(S) as a collection of subsets of S and as a
set of vectors interchangeably.
Deﬁnition 3 If |ΠC(S)| = 2m then S is considered shattered by C. In
other words, S is shattered by C if C realizes all possible dichotomies of S.
Consider as an example a ﬁnite concept class C = {c1, ..., c4} applied to
three instance vectors with the results:
x1
x2
x3
c1
1
1
1
c2
0
1
1
c3
1
0
0
c4
0
0
0
Then,
ΠC({x1}) = {(0), (1)}
shattered
ΠC({x1, x3}) = {(0, 0), (0, 1), (1, 0), (1, 1)}
shattered
ΠC({x2, x3}) = {(0, 0), (1, 1)}
not shattered
With these deﬁnitions we are ready to describe the measure of concept class
complexity.
Deﬁnition 4 (VC dimension) The VC dimension of C, noted as V Cdim(C),
is the cardinality d of the largest set S shattered by C. If all sets S (arbi-
trarily large) can be shattered by C, then V Cdim(C) = ∞.
V Cdim(C) = max{d | ∃|S| = d, and |ΠC(S)| = 2d}
The VC dimension of a class of functions C is the point d at which all
samples S with cardinality |S| > d are no longer shattered by C. As long as
C shatters S it manifests its full ”richness” in the sense that one can obtain
from S all possible results (dichotomies).
Once that ceases to hold, i.e.,
when |S| > d, it means that C has ”exhausted” its richness (complexity).
An inﬁnite VC dimension means that C maintains full richness for all sample
sizes. Therefore, the VC dimension is a combinatorial measure of a function
class complexity.
Before we consider a number of examples of geometric concept classes
and their VC dimension, it is important clarify the lower and upper bounds
(existential and universal quantiﬁers) in the deﬁnition of VC dimension.
The VC dimension is at least d if there exists some sample |S| = d which is
8.1 The VC Dimension
83
shattered by C — this does not mean that all samples of size d are shattered
by C. Conversely, in order to show that the VC dimension is at most d,
one must show that no sample of size d + 1 is shattered. Naturally, proving
an upper bound is more diﬃcult than proving the lower bound on the VC
dimension. The following examples are shown in a ”hand waiving” style
and are not meant to form rigorous proofs of the stated bounds — they are
shown for illustrative purposes only.
Intervals of the real line: The concept class C is governed by two param-
eters α1, α2 in the closed interval [0, 1]. A concept from this class will tag an
input instance 0 < x < 1 as positive if α1 ≤x ≤α2 and negative otherwise.
The VC dimension is at least 2: select a sample of 2 points x1, x2 positioned
in the open interval (0, 1). We need to show that there are values of α1, α2
which realize all the possible four dichotomies (+, +), (−, −), (+, −), (−, +).
This is clearly possible as one can place the interval [α1, α2] such the inter-
section with the interval [x1, x2] is null, (thus producing (−, −)), or to fully
include [x1, x2] (thus producing (+, +)) or to partially intersect [x1, x2] such
that x1 or x2 are excluded (thus producing the remaining two dichotomies).
To show that the VC dimension is at most 2, we need to show that any
sample of three points x1, x2, x3 on the line (0, 1) cannot be shattered. It is
suﬃcient to show that one of the dichotomies is not realizable: the labeling
(+, −, +) cannot be realizable by any interval [α1, α2] — this is because if
x1, x3 are labeled positive then by deﬁnition the interval [α1, α2] must fully
include the interval [x1, x3] and since x1 < x2 < x3 then x2 must be labeled
positive as well. Thus V Cdim(C) = 2.
Axes-aligned rectangles in the plane: We have seen this concept class
in the previous lecture — a point in the plane is labeled positive if it lies
in an axes-aligned rectangle. The concept class C is thus governed by 4
parameters. The VC dimension is at least 4: consider a conﬁguration of
4 input points arranged in a cross pattern (recall that we need only to
show some sample S that can be shattered). We can place the rectangles
(concepts of the class C) such that all 16 dichotomies can be realized (for
example, placing the rectangle to include the vertical pair of points and
exclude the horizontal pair of points would induce the labeling (+, −, +, −)).
It is important to note that in this case, not all conﬁgurations of 4 points
can be shattered — but to prove a lower bound it is suﬃcient to show
the existence of a single shattered set of 4 points. To show that the VC
dimension is at most 4, we need to prove that any set of 5 points cannot
84
The VC Dimension
be shattered.
For any set of 5 points there must be some point that is
”internal”, i.e., is neither the extreme left, right, top or bottom point of the
ﬁve. If we label this internal point as negative and the remaining 4 points as
positive then there is no axes-aligned rectangle (concept) which cold realize
this labeling (because if the external 4 points are labeled positive then they
must be fully within the concept rectangle, but then the internal point must
also be included in the rectangle and thus labeled positive as well).
Separating hyperplanes: Consider ﬁrst linear half spaces in the plane.
The lower bound on the VC dimension is 3 since any three (non-collinear)
points in R2 can be shattered, i.e., all 8 possible labelings of the three points
can be realized by placing a separating line appropriately. By having one
of the points on one side of the line and the other two on the other side we
can realize 3 dichotomies and by placing the line such that all three points
are on the same side will realize the 4th. The remaining 4 dichotomies are
realized by a sign ﬂip of the four previous cases. To show that the upper
bound is also 3, we need to show that no set of 4 points can be shattered.
We consider two cases: (i) the four points form a convex region, i.e., lie on
the convex hull deﬁned by the 4 points, (ii) three of the 4 points deﬁne the
convex hull and the 4th point is internal. In the ﬁrst case, the labeling which
is positive for one diagonal pair and negative to the other pair cannot be
realized by a separating line. In the second case, a labeling which is positive
for the three hull points and negative for the interior point cannot be realize.
Thus, the VC dimension is 3 and in general the VC dimension for separating
hyperplanes in Rn is n + 1.
Union of a ﬁnite number of intervals on the line: This is an example
of a concept class with an inﬁnite VC dimension. For any sample of points
on the line, one can place a suﬃcient number of intervals to realize any
labeling.
The examples so far were simple enough that one might get the wrong
impression that there is a correlation between the number of parameters
required to describe concepts of the class and the VC dimension.
As a
counter example, consider the two parameter concept class:
C = {sign(sin(ωx + θ) : ω}
which has an inﬁnite VC dimension as one can show that for every set
of m points on the line one can realize all possible labelings by choosing
8.2 The Relation between VC dimension and PAC Learning
85
a suﬃciently large value of ω (which serves as the frequency of the sync
function) and appropriate phase.
We conclude this section with the following claim:
Theorem 7 The VC dimension of a ﬁnite concept class |C| < ∞is bounded
from above:
V Cdim(C) ≤log2 |C|.
Proof:
if V Cdim(C) = d then there exists at least 2d functions in C
because every function induces a labeling and there are at least 2d labelings.
Thus, from |C| ≥2d follows that d ≤log2 |C|.
8.2 The Relation between VC dimension and PAC Learning
We saw that the VC dimension is a combinatorial measure of concept class
complexity and we would like to have it replace the cardinality term in the
sample complexity bound.
The ﬁrst result of interest is to show that if
the VC dimension of the concept class is inﬁnite then the class is not PAC
learnable.
Theorem 8 Concept class C with V Cdim(C) = ∞is not learnable in the
formal sense.
Proof: Assume the contrary that C is PAC learnable. Let L be the learning
algorithm and m be the number of training examples required to learn the
concept class with accuracy ϵ = 0.1 and 1 −δ = 0.9. That is, after seeing
at least m(ϵ, δ) training examples, the learner generates a concept h which
satisﬁes p(err(h) ≤0.1) ≥0.9.
Since the VC dimension is inﬁnite there exist a sample set S with 2m
instances which is shattered by C. Since the formal model (PAC) applies
to any training sample we will use the set S as follows. We will deﬁne a
probability distribution on the instance space X which is uniform on S (with
probability
1
2m) and zero everywhere else.
Because S is shattered, then any target concept is possible so we will
choose our target concept c in the following manner:
prob(ct(xi) = 0) = 1
2
∀xi ∈S,
in other words, the labels ct(xi) are determined by a coin ﬂip. The learner
L selects an i.i.d. sample of m instances ¯S — which due to the structure of
86
The VC Dimension
D means that the ¯S ⊂S and outputs a consistent hypothesis h ∈C. The
probability of error for each xi ̸∈¯S is:
prob(ct(xi) ̸= h(xi)) = 1
2.
The reason for that is because S is shattered by C, i.e., we can select any
target concept for any labeling of S (the 2m examples) therefore we could
select the labels of the m points not seen by the learner arbitrarily (by
ﬂipping a coin). Regardless of h, the probability of mistake is 0.5. The
expectation on the error of h is:
E[err(h)] = m · 0 · 1
2m + m · 1
2 · 1
2m = 1
4.
This is because we have 2m points to sample (according to D as all other
points have zero probability) from which the error on half of them is zero
(as h is consistent on the training set ¯S) and the error on the remaining half
is 0.5. Thus, the average error is 0.25. Note that E[err(h)] = 0.25 for any
choice of ϵ, δ as it is based on the sample size m. For any sample size m we
can follow the construction above and generate the learning problem such
that if the learner produces a consistent hypothesis the expectation of the
error will be 0.25.
The result that E[err(h)] = 0.25 is not possible for the accuracy and
conﬁdence values we have set: with probability of at least 0.9 we have that
err(h) ≤0.1 and with probability 0.1 then err(h) = β where 0.1 < β ≤1.
Taking the worst case of β = 1 we come up with the average error:
E[err(h)] ≤0.9 · 0.1 + 0.1 · 1 = 0.19 < 0.25.
We have therefore arrived to a contradiction that C is PAC learnable.
We next obtain a bound on the growth of |ΠS(C)| when the sample size
|S| = m is much larger than the VC dimension V Cdim(C) = d of the
concept class. We will need few more deﬁnitions:
Deﬁnition 5 (Growth function)
ΠC(m) = max{|ΠS(C)| : |S| = m}
The measure ΠC(m) is the maximum number of dichotomies induced by C
for samples of size m. As long as m ≤d then ΠC(m) = 2m. The question
is what happens to the growth pattern of ΠC(m) when m > d. We will
see that the growth becomes polynomial — a fact which is crucial for the
learnability of C.
8.2 The Relation between VC dimension and PAC Learning
87
Deﬁnition 6 For any natural numbers m, d we have the following deﬁnition:
Φd(m)
=
Φd(m −1) + Φd−1(m −1)
Φd(0)
=
Φ0(m) = 1
By induction on m, d it is possible to prove the following:
Theorem 9
Φd(m) =
d
X
i=0
m
i

Proof:
by induction on m, d. For details see [[3], pp. 56].
For m ≤d we have that Φd(m) = 2m.
For m > d we can derive a
polynomial upper bound as follows.
 d
m
d
d
X
i=0
m
i

≤
d
X
i=0
 d
m
i m
i

≤
m
X
i=0
 d
m
i m
i

= (1 + d
m)m ≤ed
From which we obtain:
 d
m
d
Φd(m) ≤ed.
Dividing both sides by
  d
m
d yields:
Φd(m) ≤ed m
d
d
=
em
d
d
= O(md).
We need one more result before we are ready to present the main result of
this lecture:
Theorem 10 (Sauer’s lemma) If V Cdim(C) = d, then for any m,
ΠC(m) ≤Φd(m).
Proof:
By induction on both d, m. For details see [[3], pp. 55–56].
Taken together, we have now a fairly interesting characterization on how
the combinatorial measure of complexity of the concept class C scales up
with the sample size m. When the VC dimension of C is inﬁnite the growth
is exponential, i.e., ΠC(m) = 2m for all values of m. On the other hand,
when the concept class has a bounded VC dimension V Cdim(C) = d < ∞
then the growth pattern undergoes a discontinuity from an exponential to
a polynomial growth:
ΠC(m) =
(
2m
m ≤d
≤
  em
d
d
m > d
)
88
The VC Dimension
As a direct result of this observation, when m >> d is much larger than d
the entropy becomes much smaller than m. Recall than from an informa-
tion theoretic perspective, the entropy of a random variable Z with discrete
values z1, ..., zn with probabilities pi, i = 1, ..., n is deﬁned as:
H(Z) =
n
X
i=0
pi log2
1
pi
,
where I(pi) = log2
1
pi is a measure of ”information”, i.e., is large when
pi is small (meaning that there is much information in the occurrence of
an unlikely event) and vanishes when the event is certain pi = 1.
The
entropy is therefore the expectation of information. Entropy is maximal for
a uniform distribution H(Z) = log2 n. The entropy in information theory
context can be viewed as the number of bits required for coding z1, ..., zn. In
coding theory it can be shown that the entropy of a distribution provides the
lower bound on the average length of any possible encoding of a uniquely
decodable code fro which one symbol goes into one symbol.
When the
distribution is uniform we will need the maximal number of bits, i.e., one
cannot compress the data. In the case of concept class C with VC dimension
d, we see that one when m ≤d all possible dichotomies are realized and
thus one will need m bits (as there are 2m dichotomies) for representing
all the outcomes of the sample.
However, when m >> d only a small
fraction of the 2m dichotomies can be realized, therefore the distribution
of outcomes is highly non-uniform and thus one would need much less bits
for coding the outcomes of the sample. The technical results which follow
are therefore a formal way of expressing in a rigorous manner this simple
truth — If it is possible to compress, then it is possible to learn. The crucial
point is that learnability is a direct consequence of the ”phase transition”
(from exponential to polynomial) in the growth of the number of dichotomies
realized by the concept class.
In the next lecture we will continue to prove the ”double sampling” the-
orem which derives the sample size complexity as a function of the VC
dimension.
9
The Double-Sampling Theorem
In this lecture will use the measure of VC dimension, which is a combina-
torial measure of concept class complexity, to bound the sample size com-
plexity.
9.1 A Polynomial Bound on the Sample Size m for PAC Learning
In this section we will follow the material presented in Kearns & Vazirani
[3] pp. 57–61 and prove the following:
Theorem 11 (Double Sampling) Let C be any concept class of VC di-
mension d. Let L be any algorithm that when given a set S of m labeled
examples {xi, c(xi)}i, sampled i.i.d according to some ﬁxed but unknown
distribution D over the instance space X, of some concept c ∈C, produces
as output a concept h ∈C that is consistent with S. Then L is a learning
algorithm in the formal sense provided that the sample size obeys:
m ≥c0
1
ϵ log 1
δ + d
ϵ log 1
ϵ

for some constant c0 > 0.
The idea behind the proof is to build an ”approximate” concept space which
includes concepts arranged such that the distance between the approximate
concepts h and the target concept c is at least ϵ — where distance is de-
ﬁned as the weight of the region in X which is in conﬂict with the target
concept. To formalize this story we will need few more deﬁnitions. Unless
speciﬁed otherwise, c ∈C denotes the target concept and h ∈C denotes
some concept.
89
90
The Double-Sampling Theorem
Deﬁnition 7
c∆h = h∆c = {x : c(x) ̸= h(x)}
c∆h is the region in instance space where both concepts do not agree —
the error region. The probability that x ∈c∆h is equal to (by deﬁnition)
err(h).
Deﬁnition 8
∆(c)
=
{h∆c : h ∈C}
∆ϵ(c)
=
{h∆c : h ∈C and err(h) ≥ϵ}
∆(c) is a set of error regions, one per concept h ∈C over all concepts. The
error regions are with respect to the target concept. The set ∆ϵ(c) ⊂∆(c)
is the set of all error regions whose weight exceeds ϵ. Recall that weight is
deﬁned as the probability that a point sampled according to D will hit the
region.
It will be important for later to evaluate the VC dimension of ∆(c). Unlike
C, we are not looking for the VC dimension of a class of function but the
VC dimension of a set of regions in space. Recall the deﬁnition of ΠC(S)
from the previous lecture: there were two equivalent deﬁnitions one based
on a set of vectors each representing a labeling of the instances of S induced
by some concept. The second, yet equivalent, deﬁnition is based on a set
of subsets of S each induced by some concept (where the concept divides
the sample points of S into positive and negative labeled points). So far it
was convenient to work with the ﬁrst deﬁnition, but for evaluating the VC
dimension of ∆(c) it will be useful to consider the second deﬁnition:
Π∆(c)(S) = {r ∩S : r ∈∆(c)},
that is, the collection of subsets of S induced by intersections with regions
of ∆(c). An intersection between S and a region r is deﬁned as the subset of
points from S that fall into r. We can easily show that the VC dimensions
of C and ∆(c) are equal:
Lemma 1
V Cdim(C) = V Cdim(∆(c)).
Proof:
we have that the elements of ΠC(S) and Π∆(c)(S) are susbsets of
S, thus we need to show that for every S the cardinality of both sets is
equal |ΠC(S)| = |Π∆(c)(S)|. To do that it is suﬃcient to show that for every
element s ∈ΠC(S) there is a unique corresponding element in Π∆(c)(S). Let
9.1 A Polynomial Bound on the Sample Size m for PAC Learning
91
c∩S be the subset of S induced by the target concept c. The set s (a subset
of S) is realized by some concept h (those points in S which were labeled
positive by h). Therefore, the set s ∩(c ∩S) is the subset of S containing
the points that hit the region h∆c which is an element of Π∆(c)(S). Since
this is a one-to-one mapping we have that |ΠC(S)| = |Π∆(c)(S)|.
Deﬁnition 9 (ϵ-net) For every ϵ > 0, a sample set S is an ϵ-net for ∆(c)
if every region in ∆ϵ(c) is hit by at least one point of S:
∀r ∈∆ϵ(c),
S ∩r ̸= ∅.
In other words, if S hits all the error regions in ∆(c) whose weight exceeds
ϵ, then S is an ϵ-net. Consider as an example the concept class of intervals
on the line [0, 1]. A concept is deﬁned by an interval [α1, α2] such that all
points inside the interval are positive and all those outside are negative.
Given c ∈C is the target concept and h ∈C is some concept, then the
error region h∆c is the union of two intervals: I1 consists of all points x ∈h
which are not in c, and I2 the interval of all points x ∈c but which are not
in h. Assume that the distribution D is uniform (just for the sake of this
example) then, prob(x ∈I) = |I| which is the length of the interval I. As a
result, err(h) > ϵ if either |I1| > ϵ/2 or |I2| > ϵ/2. The sample set
S = {x = kϵ
2
: k = 0, 1, ..., 2/ϵ}
contains sample points from 0 to 1 with increments of ϵ/2. Therefore, every
interval larger than ϵ must be hit by at least one point from S and by
deﬁnition S is an ϵ-net.
It is important to note that if S forms an ϵ-net then we are guaranteed
that err(h) ≤ϵ. Let h ∈C be the consistent hypothesis with S (returned
by the learning algorithm L).
Becuase h is consistent, h∆c ∈∆(c) has
not been hit by S (recall that h∆c is the error region with respect to the
target concept c, thus if h is consistent then it agrees with c over S and
therefore S does not hit h∆c). Since S forms an ϵ-net for ∆(c) we must
have h∆c ̸∈∆ϵ(c) (recall that by deﬁnition S hits all error regions with
weight larger than ϵ). As a result, the error region h∆c must have a weight
smaller than ϵ which means that err(h) ≤ϵ.
The conclusion is that if we can bound the probability that a random sam-
ple S does not form an ϵ-net for ∆(c), then we have bounded the probability
that a concept h consistent with S has err(h) > ϵ. This is the goal of the
proof of the double-sampling theorem which we are about to prove below:
92
The Double-Sampling Theorem
Proof (following Kearns & Vazirani [3] pp. 59–61): Let S1 be a ran-
dom sample of size m (sampled i.i.d. according to the unknown distribution
D) and let A be the event that S1 does not form an ϵ-net for ∆(c). From
the preceding discussion our goal is to upper bound the probability for A to
occur, i.e., prob(A) ≤δ.
If A occurs, i.e., S1 is not an ϵ-net, then by deﬁnition there must be some
region r ∈∆ϵ(c) which is not hit by S1, that is S1 ∩r = ∅. Note that
r = h∆(c) for some concept h which is consistent with S1. At this point the
space of possibilities is inﬁnite, because the probability that we fail to hit
h∆(c) in m random examples is at most (1−ϵ)m. Thus the probability that
we fail to hit some h∆c ∈∆ϵ(c) is bounded from above by |∆(c)|(1 −ϵ)m
— which does not help us due to the fact that |∆(c)| is inﬁnite. The idea
of the proof is to turn this into a ﬁnite space by using another sample, as
follows.
Let S2 be another random sample of size m. We will select m (for both
S1 and S2) to guarantee a high probability that S2 will hit r many times.
In fact we wish that S2 will hit r at least ϵm
2 with probability of at least 0.5:
prob(|S2 ∩r| > ϵm
2 ) = 1 −prob(|S2 ∩r| ≤ϵm
2 ).
We will use the Chernoﬀbound (lower tail) to obtain a bound on the right-
hand side term.
Recall that if we have m Bernoulli trials (coin tosses)
Z1, ..., Zm with expectation E(Zi) = p and we consider the random variable
Z = Z1 + ... + Zm with expectation E(Z) = µ (note that µ = pm) then for
all 0 < ψ < 1 we have:
prob(Z < (1 −ψ)µ) ≤e−µψ2
2 .
Considering the sampling of m examples that form S2 as Bernoulli trials,
we have that µ ≥ϵm (since the probability that an example will hit r is at
least ϵ) and ψ = 0.5. We obtain therefore:
prob(|S2 ∩r| ≤(1 −1
2)ϵm) ≤e−ϵm
8 = 1
2
which happens when m =
8
ϵ ln 2 = O(1
ϵ).
To summarize what we have
obtained so far, we have calculated the probability that S2 will hit r many
times given that r was ﬁxed using the previous sampling, i.e., given that S1
does not form an ϵ-net. To formalize this, let B denote the combined event
that S1 does not form an ϵ-event and S2 hits r at least ϵm/2 times. Then,
we have shown that for m = O(1/ϵ) we have:
prob(B/A) ≥1
2.
9.1 A Polynomial Bound on the Sample Size m for PAC Learning
93
From this we can calculate prob(B):
prob(B) = prob(B/A)prob(A) ≥1
2prob(A),
which means that our original goal of bounding prob(A) is equivalent to
ﬁnding a bound prob(B) ≤δ/2 because prob(A) ≤2 · prob(B) ≤δ. The
crucial point with the new goal is that to analyze the probability of the
event B, we need only to consider a ﬁnite number of possibilities, namely to
consider the regions of
Π∆ϵ(c)(S1 ∪S2) = {r ∩{S1 ∪S2} : r ∈∆ϵ(c)} .
This is because the occurrence of the event B is equivalent to saying that
there is some r ∈Π∆ϵ(c)(S1 ∪S2) such that |r| ≥ϵm/2 (i.e., the region r
is hit at least ϵm/2 times) and S1 ∩r = ∅. This is because Π∆ϵ(c)(S1 ∪S2)
contains all the subsets of S1 ∪S2 realized as intersections over all regions
in ∆ϵ(c). Thus even though we have an inﬁnite number of regions we still
have a ﬁnite number of subsets. We wish therefore to analyze the following
probability:
prob
 r ∈Π∆ϵ(c)(S1 ∪S2) : |r| ≥ϵm/2 and S1 ∩r = ∅

.
Let S = S1∪S2 a random sample of 2m (note that since the sampling is i.i.d.
it is equivalent to sampling S1 and S2 separately) and r satisfying |r| ≥ϵm/2
being ﬁxed. Consider some random partitioning of S into S1 and S2 and
consider then the problem of estimating the probability that S1 ∩r = ∅.
This problem is equivalent to the following combinatorial question: we have
2m balls, each colored Red or Blue, with exaclty l ≥ϵm/2 Red balls. We
divide the 2m balls into groups of equal size S1 and S2 and we are interested
in bounding the probability that all of the l balls fall in S2 (that is, the
probability that S1 ∩r = ∅). This in turn is equivalent to ﬁrst dividing the
2m uncolored balls into S1 and S2 groups and then randomly choose l of
the balls to be colored Red and analyze the probability that all of the Red
balls fall into S2. This probability is exactly
 m
l

 2m
l
 =
l−1
Y
i=0
m −i
2m −i ≤
l−1
Y
i=0
1
2 = 1
2l = 2−ϵm/2.
This probability was evaluated for a ﬁxed S and r. Thus, the probability that
this occurs for some r ∈Π∆ϵ(c)(S) satisfying |r| ≥ϵm/2 (which is prob(B))
can be calculated by summing over all possible ﬁxed r and applying the
94
The Double-Sampling Theorem
union bound prob(P
i Zi) ≤P
i prob(Zi):
prob(B)
≤
|Π∆ϵ(c)(S)|2−ϵm/2 ≤|Π∆(c)(S)|2−ϵm/2
=
|ΠC(S)|2−ϵm/2 ≤
2ϵm
d
d
2−ϵm/2 ≤δ
2,
from which it follows that:
m = O
1
ϵ log 1
δ + d
ϵ log 1
ϵ

.
Few comments are worthwhile at this point:
(i) It is possible to show that the upper bound on the sample complexity
m is tight by showing that the lower bound on m is Ω(d/ϵ) (see [[3],
pp. 62]).
(ii) The treatment above holds also for the unrealizable case (target con-
cept c ̸∈C) with slight modiﬁcations to the bound. In this context,
the learning algorithm L must simply minimize the sample (empiri-
cal) error ˆ
err(h) deﬁned:
ˆ
err(h) = 1
m|{i : h(xi) ̸= yi}|
xi ∈S.
The generalization of the double-sampling theorem (Derroye’82) states
that the empirical errors converge uniformly to the true errors:
prob

max
h∈C |
ˆ
err(h) −err(h)| ≥ϵ

≤4e(4ϵ+4ϵ2)
ϵm2
d
d
2−mϵ2/2 ≤δ,
from which it follows that
m = O
 1
ϵ2 log 1
δ + d
ϵ2 log 1
ϵ

.
Taken together, we have arrived to a fairly remarkable result. Despite the
fact that the distribution D from which the training sample S is drawn from
is unknown (but is known to be ﬁxed), the learner simply needs to minimize
the empirical error. If the sample size m is large enough the learner is guar-
anteed to have minimized the true errors for some accuracy and conﬁdence
parameters which deﬁne the sample size complexity. Equivalently,
|Opt(C) −ˆ
err(h)| −→m→∞0.
Not only is the convergence is independent of D but also the rate of con-
vergence is independent (namely, it does not matter where the optimal h∗
9.2 Optimality of SVM Revisited
95
is located). The latter is very important because without it one could ar-
bitrarily slow down the convergence rate by maliciously choosing D. The
beauty of the results above is that D does not have an eﬀect at all — one
simply needs to choose the sample size to be large enough for the accuracy,
conﬁdence and VC dimension of the concept class to be learned over.
9.2 Optimality of SVM Revisited
In Lecture 4 we discussed the large margin principle for ﬁnding an optimal
separating hyperplane. It is natural to ask how does the PAC theory pre-
sented so far explains why a maximal margin hyperplane is optimal with
regard to the formal sense of learning (i.e. to generalization from empirical
errors to true errors)? We saw in the previous section that the sample com-
plexity m(ϵ, δ, d) depends also on the VC dimension of the concept class —
which is n + 1 for hyperplanes in Rn. Thus, another natural question that
may certainly arise is what is the gain in employing the ”kernel trick”? For a
ﬁxed m, mapping the input instance space X of dimension n to some higher
(exponentially higher) feature space might simply mean that we are compro-
mising the accuracy and conﬁdence of the learner (since the VC dimension
is equal to the instance space dimension plus 1).
Given a ﬁxed sample size m, the best the learner can do is to minimize the
empirical error and at the same time to try to minimize the VC dimension d
of the concept class. The smaller d is, for a ﬁxed m, the higher the accuracy
and conﬁdence of the learning algorithm. Likewise, the smaller d is, for a
ﬁxed accuracy and conﬁdence values, the smaller sample size is required.
There are two possible ways to decrease d. First is to decrease the dimen-
sion n of the instance space X. This amounts to ”feature selection”, namely
ﬁnd a subset of coordinates that are the most ”relevant” to the learning
task r perform a dimensionality reduction via PCA, for example. A second
approach is to maximize the margin. Let the margin associated with the
separating hyperplane h (i.e. consistent with the sample S) be γ. Let the
input vectors x ∈X have a bounded norm, |x| ≤R. It can be shown that
the VC dimension of the concept class Cγ of hyperplanes with margin γ is:
Cγ = min
R2
γ2 , n

+ 1.
Thus, if the margin is very small then the VC dimension remains n + 1. As
the margin gets larger, there comes a point where R2/γ2 < n and as a result
the VC dimension decreases. Moreover, mapping the instance space X to
some higher dimension feature space will not change the VC dimension as
96
The Double-Sampling Theorem
long as the margin remains the same. It is expected that the margin will not
scale down or will not scale down as rapidly as the scaling up of dimension
from image space to feature space.
To conclude, maximizing the margin (while minimizing the empirical er-
ror) is advantageous as it decreases the VC dimension of the concept class
and causes the accuracy and conﬁdence values of the learner to be largely
immune to dimension scaling up while employing the kernel trick.
10
Appendix
97
98
Appendix
A0.1 Variance, Covariance, etc.
Let X, Y be two random variables and let f(x, y) be some function on x ∈
X, y ∈Y , and let p(x, y) be the probability of the event x and y occurring
together. The expectation E[f(x, y)] is deﬁned:
E[f(x, y)] =
X
x∈X
X
y∈Y
f(x, y)p(x, y)
. The mean, variance and covariance are deﬁned:
µx
=
E[X] =
X
x
X
y
xp(x, y)
µy
=
E[Y ] =
X
x
X
y
yp(x, y)
σ2
x
=
V ar[X] = E[(x −µx)2] =
X
x
X
y
(x −µx)2p(x, y)
σ2
y
=
V ar[Y ] = E[(y −µy)2] =
X
x
X
y
(y −µy)2p(x, y)
σxy
=
Cov(XY ) = E[(x −µx)(y −µy)] =
X
x
X
y
(x −µx)(y −µy)p(x, y)
In vector-matrix notation, let x represent the n random variables of X1, ..., Xn,
i.e., x = (x1, ..., xn)⊤is an instance vector and p(x) is the probability of the
instance occurrence. Then the mean is a vector µ and the covariance matrix
E are deﬁned:
µ
=
X
x∈{X1,...,Xn}
xp(x)
E
=
X
x
(x −µ)(x −µ)⊤p(x)
Note that the covariance matrix E is the linear superposition of rank-1
matrices (x−µ)(x−µ)⊤with coeﬃcients p(x). The diagonal of E containes
the variances of the variables x1, ..., xn.
For a uniform distribution and
a sample data S consisting of m points, let A = [x1 −µ, ..., xm −µ] be
the matrix whose columns consist of the points centered around the mean:
µ = 1
m
P
i xi. The (sample) covariance matrix is E = 1
mAA⊤.
A0.2 Derivatives of Matrix Operations: Scalar Functions of a Vector
99
A0.2 Derivatives of Matrix Operations: Scalar Functions of a
Vector
The two most important examples of a scalar function of a vector x are the
linear form a⊤x and the quadratic form x⊤Ax for some square matrix A.
d(a⊤x)
=
a⊤dx
d(x⊤Ax)
=
(dx)⊤Ax + x⊤A(dx)
=

(dx)⊤Ax
⊤
+ x⊤A(dx)
=
x⊤(A + A⊤)dx
where the derivative d(x⊤Ax) using the rule of products d(f · g) = (df) · g +
f · (dg) where g = Ax and f = x⊤and noting that d(Ax) = Adx. Thus,
d
dx(a⊤x) = a⊤and
d
dx(x⊤Ax)) = x⊤(A + A⊤). If A is symmetric then
d
dx(x⊤Ax)) = (2Ax)⊤.
A0.3 Primer on Constrained Optimization
A0.3.1 Equality Constraints and Lagrange Multipliers
Consider ﬁrst the general optimization with equality constraints which gives
rise to the notion of Lagrange multipliers.
min
x
f(x)
(0.1)
subject to
h(x) = 0
where f : Rn →R and h : Rn →Rk where h is a vector function (h1, ..., hk)
each from Rn to R. We want to derive a necessary and suﬃcient constraint
for a point xo to be a local minimum subject to the k equality constraints
h(x) = 0. Assume that xo is a regular point, meaning that the gradient
vectors ∇hj(x) are linearly independent. Note that ∇h(xo) is a k×n matrix
and the null space of this matrix:
null(∇h(xo)) = {y : ∇h(xo)y = 0}
deﬁnes the tangent plane at the point xo. We have the following fundamental
theorem:
∇f(xo) ⊥null(∇h(xo))
in other words, all vectors y spanning the tangent plane at the point xo are
also perpendicular to the gradient of f at xo.
100
Appendix
The sketch of the proof is as follows. Let x(t), −a ≤t < a, be a smooth
curve on the surface h(x) = 0, i.e., h(x(t)) = 0. Let xo = x(0) and y =
d
dtx(0) the tangent to the curve at xo. From the deﬁnition of tangency, the
vector y lives in null(∇h(xo)), i.e., y · ∇hj(x(0)) = 0, j = 1, ..., k. Since
xo = x(0) is a local extremum of f(x), then
0 = d
dtf(x(t))|t=0 =
X ∂f
∂xi
dxi
dt |t=0 = ∇f(xo) · y.
As a corollary of this basic theorem, the gradient vector ∇f(xo) ∈span{∇h1(xo), ..., ∇hk(xo)},
i.e.,
∇f(xo) +
k
X
i=1
λi∇hi(xo) = 0,
where the coeﬃcients λi are called Lagrange Multipliers and the expression:
f(x) +
X
i
λihi(x)
is called the Lagrangian of the optimization problem (0.1).
A0.3.2 Inequality Constraints and KKT conditions
Consider next the general constrained optimization with inequality con-
straints (called “non-linear programming”):
min
x
f(x)
(0.2)
subject to
h(x) = 0
g(x) ≤0
where g : Rn →Rs.
We will assume that the optimal solution xo is a
regular point which has the following meaning: Let J be the set of indices
j such that gj(xo) = 0, then xo is a regular point if the gradient vectors
∇hi(xo), ∇gj(xo), i = 1, ..., k and j ∈J are linearly independent. A basic
result (we will not prove here) is the Karush-Kuhn-Tucker (KKT) theorem:
Let xo be a local minimum of the problem and suppose xo is a regular
point. Then, there exist λ1, ..., λk and µ1 ≥0, ..., µs ≥0 such that:
A0.3 Primer on Constrained Optimization
101
)
,
(
*
* z
y
)
,
(
z
y
y
z
!
µ =
+
y
z
G
n
R
x "
))
(
),
(
(
x
f
x
g
)
(µ
#
Fig. A0.1. Geometric interpreatation of Duality (see text).
∇f(xo) +
k
X
i=1
λi∇hi(xo) +
s
X
j=1
µj∇gj(xo)
=
0,
(0.3)
s
X
j=1
µjgj(xo)
=
0.
(0.4)
Note that the condition P µjgj(xo) = 0 is equivalent to the condition that
µjgj(xo) = 0 (since µ ≥0 and g(xo) ≤0 thus there sum cannot vanish
unless each term vanishes) which in turn implies: µj = 0 when gj(xo) < 0.
The expression
L(x, λ, µ) = f(x) +
k
X
i=1
λihi(x) +
s
X
j=1
µjgj(x)
is the Lagrangian of the problem (0.2) and the associated condition µjgj(xo) =
0 is called the KKT condition.
The remaining concepts we need are the “duality” and the “Lagrangian
Dual” problem.
102
Appendix
A0.3.3 The Langrangian Dual Problem
The optimization problem (0.2) is called the “Primal” problem. The La-
grangian Dual problem is deﬁned as:
max
λ,µ
θ(λ, µ)
(0.5)
subject to
µ ≥0
(0.6)
where
θ(λ, µ) = min
x {f(x) +
X
i
λihi(x) +
X
j
µjgj(x)}.
Note that θ(λ, µ) may assume the value −∞for some values of λ, µ (thus
to be rigorous we should have replaced “min” with “inf”). The ﬁrst basic
result is the weak duality theorem:
Let x be a feasible solution to the primal (i.e., h(x) = 0, g(x) ≤0) and let
(λ, µ) be a feasible solution to the dual problem (i.e., µ ≥0), then f(x) ≥
θ(λ, µ)
The proof is immediate:
θ(λ, µ)
=
min
y {f(y) +
X
i
λihi(y) +
X
j
µjgj(y)}
≤
f(x) +
X
i
λihi(x) +
X
j
µjgj(x)
≤
f(x)
where the latter inequality follows from h(x) = 0 and P
j µjgj(x) ≤0
because µ ≥0 and g(x) ≤0. As a corollary of this theorem we have:
min
x {f(x) : h(x) = 0, g(x) ≤0} ≥max
λ,µ {θ(λ, µ) : µ ≥0}.
(0.7)
The next basic result is the strong duality theorem which speciﬁes the con-
ditions for when the inequality in (0.7) becomes equality:
Let f(), g() be convex functions and let h() be aﬃne, i.e., h(x) = Ax −b
where A is a k × n matrix, then
min
x {f(x) : h(x) = 0, g(x) ≤0} = max
λ,µ {θ(λ, µ) : µ ≥0}.
The strong duality theorem allows one to solve for the primal problem by
ﬁrst dualizing it and solving for the dual problem instead (we will see exactly
how to do it when we return to solving the primal problem (4.3)). When
A0.3 Primer on Constrained Optimization
103
)
,
(
*
* z
y
y
z
G
*
µ
optimal primal
optimal dual
Fig. A0.2. An example of duality gap arising from non-convexity (see text).
the (convexity) conditions above do not hold we obtain
min
x {f(x) : h(x) = 0, g(x) ≤0} > max
λ,µ {θ(λ, µ) : µ ≥0}
which means that the optimal solution to the dual problem provides only a
lower bound to the primal problem — this situation is called a duality gap.
Taken together, the ”duality theorem” summarizes the discussion so far:
Theorem 12 (Duality Theorem) In order for x∗to be an optimal Primal
solution and (λ∗, µ∗) to be an optimal Dual solution, it is necessary and
suﬃcient that:
(i) x∗is Primal feasible,
(ii) µ∗≥0 and µ∗j = 0 for all gj(x∗) < 0,
(iii) x∗∈argminxL(x, λ∗, µ∗).
We will end this section with a geometric interpretation of duality.
A0.3.4 Geometric Interpretation of Duality
For clarity we will consider a primal problem with a single inequality con-
straint: min{f(x) : g(x) ≤0} where g : Rn →R.
Consider the set G = {(y, z) : y = g(x), z = f(x)} in the (y, z) plane. The
set G is the image of Rn under the (g, f) map (see Fig. A0.1). The primal
104
Appendix
problem is to ﬁnd a point in G that has a y ≤0 with the smallest z value
— this is the point (y∗, z∗) in the ﬁgure.
In this case θ(µ) = minx{f(x) + µg(x)} which is equivalent to minimize
z + µy over points in G. The equation z + µy = α represents a straight line
with slope −µ and intercept (on z axis) α. For a given value µ, to minimize
z + µy over G we need to move the line z + µy = α parallel to itself as far
down as possible while it remains in contact with G — in other words G
is above the line and touches it. Then, the intercept with the z axis gives
θ(µ). The dual problem is therefore equivalent to ﬁnding the slope of the
supporting hyperplane such that its intercept on the z axis is maximal.
Consider the non-convex region G in Fig. A0.2 which illustrates a duality
gap condition. The optimal primal is the point (y∗, z∗) which is higher than
the greatest intercept on the z axis achieved by a line that supports G from
below. This is an example of a duality gap caused by the non-convexity of
the functions f(), g() (thereby making the set G non-convex).
Bibliography
M. Anthony and P.L. Bartlett. Neural Neteowk Learning: Theoretical Foundations.
Cambridge University Press, 1999.
K.M. Hall. An r-dimensional quadratic placement algorithm. Manag. Sci., 17:219–
229, 1970.
M.J. Kearns and U.V. Vazirani. An Introduction to Computational Learning The-
ory. MIT Press, 1997.
Y. Linde, A. Buzo, and R.M. Gray. An algorithm for vector quantizer design. IEEE
Transactions on Communications, 1:84–95, 1980.
A.Y. Ng, M.I. Jordan, and Y. Weiss.
On spectral clustering: Analysis and an
algorithm. In Proceedings of the conference on Neural Information Processing
Systems (NIPS), 2001.
J. Shi and J. Malik. Normalized cuts and image segmentation. IEEE Transactions
on Pattern Analysis and Machine Intelligence, 22(8), 2000.
R. Zass and A. Shashua. A unifying approach to hard and probabilistic clustering.
In Proceedings of the International Conference on Computer Vision, Beijing,
China, Oct. 2005.
105
